{"version":3,"file":"index.esm.js","sources":["../src/module/ajax/download.ts","../src/module/ajax/strToBlob.ts","../src/module/ajax/downloadString.ts","../src/module/ajax/downloadUrl.ts","../src/module/ajax/splitHttpHeader.ts","../src/module/ajax/getCookies.ts","../src/module/ajax/loadResource.ts","../src/module/ajax/parseUrl.ts","../src/module/ajax/readLocal.ts","../src/module/date/dateFormat.ts","../src/module/ajax/spliceParams.ts","../src/module/async/wait.ts","../src/module/ajax/fetchTimeout.ts","../src/module/ajax/strToArrayBuffer.ts","../src/module/ajax/FetchLimiting.ts","../src/module/array/asIterator.ts","../src/module/obj/isNullOrUndefined.ts","../src/module/function/returnItself.ts","../src/module/async/compatibleAsync.ts","../src/module/function/CombinedPredicate.ts","../src/module/array/AsyncArray.ts","../src/module/array/asyncFlatMap.ts","../src/module/number/isRange.ts","../src/module/string/StringValidator.ts","../src/module/obj/TypeValidator.ts","../src/module/function/safeExec.ts","../src/module/function/extractField.ts","../src/module/array/getKFn.ts","../src/module/array/flatMap.ts","../src/module/array/groupBy.ts","../src/module/array/range.ts","../src/module/array/toObject.ts","../src/module/array/uniqueBy.ts","../src/module/array/arrayToMap.ts","../src/module/date/dateParse.ts","../src/module/date/strToDate.ts","../src/module/dom/copyText.ts","../src/module/dom/createElByString.ts","../src/module/dom/getCursorPosition.ts","../src/module/dom/getCusorPostion.ts","../src/module/dom/setCursorPosition.ts","../src/module/dom/insertText.ts","../src/module/string/toLowerCase.ts","../src/module/dom/isEditable.ts","../src/module/dom/lastFocus.ts","../src/module/dom/removeEl.ts","../src/module/dom/removeText.ts","../src/module/dom/setCusorPostion.ts","../src/module/event/watchEventListener.ts","../src/module/string/toString.ts","../src/module/formdata/appends.ts","../src/module/formdata/deletes.ts","../src/module/formdata/sets.ts","../src/module/formdata/formDataToArray.ts","../src/module/formdata/objToFormData.ts","../src/module/async/debounce.ts","../src/module/function/singleModel.ts","../src/module/function/StateMachine.ts","../src/module/async/throttle.ts","../src/module/function/timing.ts","../src/module/async/waitResource.ts","../src/module/function/watch.ts","../src/module/function/watchObject.ts","../src/module/string/fill.ts","../src/module/string/format.ts","../src/module/string/isFloat.ts","../src/module/string/isNumber.ts","../src/module/string/toUpperCase.ts","../src/module/string/blankToNull.ts","../src/module/obj/blankToNullField.ts","../src/module/obj/emptyAllField.ts","../src/module/obj/excludeFields.ts","../src/module/obj/mapToObject.ts","../src/module/number/randomInt.ts","../src/module/date/DateConstants.ts","../src/module/date/dateEnhance.ts","../src/module/date/getYearWeek.ts","../src/module/date/dateBetween.ts","../src/module/function/returnReasonableItself.ts","../src/module/array/filterItems.ts","../src/module/array/diffBy.ts","../src/module/array/arrayDiffBy.ts","../src/module/number/autoIncrement.ts","../src/module/string/StringConverter/IConverter.ts","../src/module/string/StringConverter/CamelOrPascalFrom.ts","../src/module/string/StringConverter/CamelConverter.ts","../src/module/string/StringConverter/PascalConverter.ts","../src/module/string/StringConverter/SnakeOrScreamingSnakeFrom.ts","../src/module/string/StringConverter/SnakeConverter.ts","../src/module/string/StringConverter/ScreamingSnakeConverter.ts","../src/module/string/StringConverter/StringStyleType.ts","../src/module/string/StringConverter/ConverterFactory.ts","../src/module/string/StringConverter/StringStyleConverter.ts","../src/module/cache/MemoryCache.ts","../src/module/function/onceOfSameParam.ts","../src/module/string/StringConverter.ts","../src/module/obj/deepFreeze.ts","../src/module/obj/deepProxy.ts","../src/module/function/curry.ts","../src/module/array/sortBy.ts","../src/module/date/DateFormatter.ts","../src/module/array/findIndex.ts","../src/module/function/compose.ts","../src/module/obj/deepExcludeFields.ts","../src/module/obj/excludeFieldsDeep.ts","../src/module/cache/CacheVal.ts","../src/module/cache/ICacheOption.ts","../src/module/cache/LocalStorageCache.ts","../src/module/cache/CacheUtil.ts","../src/module/function/emptyFunc.ts","../src/module/hack/AntiDebug.ts","../src/module/string/isBlank.ts","../src/module/string/isEmpty.ts","../src/module/ajax/loadScript.ts","../src/module/function/deny.ts","../src/module/array/ArrayValidator.ts","../src/module/string/PathUtil.ts","../src/module/hack/logger.ts","../src/module/obj/objectToMap.ts","../src/module/tree/listToTree.ts","../src/module/function/bridge.ts","../src/module/tree/treeMapping.ts","../src/module/tree/treeToList.ts","../src/module/tree/NodeBridgeUtil.ts","../src/module/obj/getObjectEntries.ts","../src/module/obj/getObjectKeys.ts","../src/module/number/floatEquals.ts","../src/module/obj/assign.ts","../src/module/obj/aggregation.ts","../src/module/async/asyncLimiting.ts","../src/module/async/Locker.ts","../src/module/function/trySometime.ts","../src/module/function/trySometimeParallel.ts","../src/module/obj/compare.ts","../src/module/function/sleep.ts","../src/module/async/async.ts","../src/module/async/mergeMap.ts","../src/module/async/switchMap.ts","../src/module/function/once.ts","../src/module/async/concatMap.ts","../src/module/function/repeatedCall.ts","../src/module/function/PubSubMachine.ts","../src/module/array/extractFieldMap.ts","../src/module/array/segmentation.ts","../src/module/dom/toggleClass.ts","../src/module/function/partial.ts","../src/module/event/EventUtil.ts","../src/module/ajax/loadStyle.ts","../src/module/date/Stopwatch.ts","../src/module/hack/remindLeavePage.ts","../src/module/event/EventEmitter.ts","../src/module/async/MicrotaskQueue.ts","../src/module/string/randomStr.ts","../src/module/idea/parseFieldStr.ts","../src/module/obj/get.ts","../src/module/obj/set.ts","../src/module/dom/getSelectText.ts","../src/module/dom/imageSize.ts","../src/module/dom/getMousePos.ts","../src/module/function/batch.ts","../src/module/obj/pick.ts","../src/module/cache/proxyStorage.ts","../src/module/obj/mapObject.ts"],"sourcesContent":["/**\n * 在浏览器上下载二进制资源\n * @param blob 要下载的二进制资源\n * @param filename 文件名\n */\nexport function download(blob: Blob, filename = 'unknown') {\n  // 创建隐藏的可下载链接\n  const eleLink = document.createElement('a')\n  eleLink.download = filename\n  eleLink.style.display = 'none'\n  // 为 link 赋值\n  eleLink.href = URL.createObjectURL(blob)\n  // 触发点击\n  document.body.appendChild(eleLink)\n  eleLink.click()\n  // 然后移除\n  document.body.removeChild(eleLink)\n}\n","/**\n * 将字符串转化为 Blob 类型\n * @param str 字符串\n * @returns Blob 数据\n */\nexport function strToBlob(str: string): Blob {\n  return new Blob([str], {\n    type: 'text/plain',\n  })\n}\n","import { download } from './download'\nimport { strToBlob } from './strToBlob'\n\n/**\n * 在浏览器上下载文本内容\n * @param str 字符串内容\n * @param filename 下载文件名，没有则默认为链接中的文件名\n */\nexport async function downloadString(str: string, filename = 'unknown.txt') {\n  download(strToBlob(str), filename)\n}\n","/**\n * 根据 url 下载二进制资源\n * @param url 下载请求信息\n * @param filename 下载文件名，没有则默认为链接中的文件名\n */\nexport async function downloadUrl(\n  url: string,\n  filename: string = url.substr(url.lastIndexOf('/')),\n) {\n  // 创建隐藏的可下载链接\n  const eleLink = document.createElement('a')\n  eleLink.download = filename\n  eleLink.style.display = 'none'\n  // 为 link 赋值\n  eleLink.href = url\n  // 触发点击\n  document.body.appendChild(eleLink)\n  eleLink.click()\n  // 然后移除\n  document.body.removeChild(eleLink)\n}\n","/**\n * 分割 http 请求中 header 的内容为一个 map\n * 分隔符参考 {@link https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type}\n * @param header\n */\nexport function splitHttpHeader(header: string) {\n  return header.split(';').reduce((res, str) => {\n    let [k, v] = str.split('=')\n    if (v !== undefined) {\n      v = decodeURIComponent(v)\n    }\n    res.set(k.trim(), v)\n    return res\n  }, new Map())\n}\n","import { splitHttpHeader } from './splitHttpHeader'\n\n/**\n * 获取 cookie 键值映射 Map\n * @returns cookie 键值映射 Map\n * @deprecated 请使用更通用的 {@link splitHttpHeader} 函数\n */\nexport function getCookies() {\n  return splitHttpHeader(document.cookie)\n}\n","/**\n * 将 url 中的内容加载到元素上\n * 注：domSelector 必须有 src 属性用以将加载完成的资源赋值给其，加载默认是异步的\n * @param url url 资源\n * @param dom dom 元素\n * @param init 初始化参数, 实为 fetch() 的参数以及一些自定义的参数，默认 {}\n * 关于 fetch 具体可以参考 <https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch>\n */\nexport async function loadResource(\n  url: RequestInfo,\n  dom:\n    | HTMLImageElement\n    | HTMLAudioElement\n    | HTMLVideoElement\n    | HTMLTrackElement\n    | HTMLScriptElement,\n  init: RequestInit = {},\n) {\n  const res = await fetch(url, init)\n  const blob = await res.blob()\n  // 生成一个本地的 url 并赋值给 src 属性\n  dom.src = window.URL.createObjectURL(blob)\n}\n","/**\n * Url 对象\n */\ninterface IUrlObject {\n  /**\n   * href 不包含网站域名的链接\n   */\n  href: string\n  /**\n   * website URL 站点\n   */\n  website: string\n  /**\n   * protocol 协议\n   */\n  protocol: string\n  /**\n   * domain 域名\n   */\n  domain: string\n  /**\n   * accessPath 绝对路径,不包含参数\n   */\n  accessPath: string\n  /**\n   * params 参数列表,\n   */\n  params: Map<string, string | string[]>\n  /**\n   * url 原 url 链接\n   */\n  url: string\n  /**\n   * port 端口号\n   */\n  port: number\n}\n\n/**\n * 协议与默认端口映射表\n */\nconst protocolPortMap = new Map()\n  .set('http', 80)\n  .set('https', 443)\n  .set('ssh', 22)\n  .set('ftp', 21)\n\n/**\n * 解析 url 字符串\n * @param url url 字符串，不能为空\n * @returns url 对象\n * @deprecated 请使用原生 API URL 类，可以通过 new URL(url) 将 URL 字符串转换为 URL 对象，并获取指定的信息\n */\nexport function parseUrl(url: string): IUrlObject | null {\n  if (!url) {\n    throw new Error('Url cannot be empty')\n  }\n\n  const regexp = new RegExp('^((\\\\w+)://([\\\\w\\\\.]*)(:(\\\\d+))?)(.*)')\n  const temps = regexp.exec(url)\n  if (temps === null) {\n    return null\n  }\n  const website = temps[1]\n  const protocol = temps[2]\n  const domain = temps[3]\n  const portStr = temps[5]\n  const href = temps[6]\n\n  // 截取域名之后的内容\n  const temp = url.substr(website.length)\n  const markIndex = temp.indexOf('?')\n  // 如果没有携带参数则直接返回\n  if (markIndex === -1) {\n    const accessPath = temp\n    return {\n      url,\n      website,\n      protocol,\n      domain,\n      // tslint:disable-next-line:radix\n      port: parseInt(portStr),\n      href,\n      accessPath,\n      params: new Map<string, string>(),\n    }\n  }\n  let accessPath = temp.substr(0, markIndex)\n  if (accessPath.endsWith('/')) {\n    accessPath = accessPath.substring(0, accessPath.length - 1)\n  }\n  const port = portStr || protocolPortMap.get(protocol) || 0\n  // 解析参数列表\n  const params = temp\n    .substr(markIndex + 1)\n    .split('&')\n    .map((str) => str.split('='))\n    .filter((arr) => arr[0] !== '')\n    .reduce((params, arr: string[]) => {\n      const k = decodeURIComponent(arr[0])\n      const v = decodeURIComponent(arr.length === 1 ? '' : arr[1])\n      // 如果已经存在了就认为是数组参数\n      const vs = params.get(k)\n      if (vs === undefined) {\n        params.set(k, v)\n      } else {\n        if (!Array.isArray(vs)) {\n          params.set(k, [vs])\n        }\n        if ((params.get(k) as string[]).length !== undefined) {\n          ;(params.get(k) as string[]).push(v)\n        }\n      }\n      return params\n    }, new Map<string, string | string[]>())\n  return {\n    url,\n    website,\n    protocol,\n    domain,\n    port,\n    href,\n    accessPath,\n    params,\n  }\n}\n","/**\n * 读取文件类型\n */\nenum ReadType {\n  /**\n   * 以 data url 读取\n   */\n  DataURL = 'readAsDataURL',\n  /**\n   * 以文本读取\n   */\n  Text = 'readAsText',\n  /**\n   * 以二进制文件读取\n   */\n  BinaryString = 'readAsBinaryString',\n  /**\n   * 以 ArrayBuffer 读取\n   */\n  ArrayBuffer = 'readAsArrayBuffer',\n}\ninterface IReadLocalInit<T extends ReadType> {\n  type: T\n  encoding: string\n}\ntype ReadResult<T extends ReadType> = T extends ReadType.DataURL | ReadType.Text\n  ? string\n  : ArrayBuffer\n\n/**\n * 读取本地浏览器选择的文件\n * @param file 选择的文件\n * @param options 读取的选项\n * @returns 返回了读取到的内容（异步）\n */\nexport function _readLocal<T extends ReadType>(\n  file: File,\n  options: Partial<{\n    type: T\n    encoding: string\n  }> = {},\n): Promise<ReadResult<T> | null> {\n  const { type, encoding } = Object.assign(\n    {\n      type: ReadType.DataURL,\n      encoding: 'UTF-8',\n    },\n    options,\n  )\n  return new Promise((resolve, reject) => {\n    if (!file) {\n      reject(new Error('file not exists'))\n    }\n    const fr = new FileReader()\n    fr.onload = () => {\n      resolve(fr.result as ReadResult<T>)\n    }\n    fr.onerror = (error) => {\n      reject(error)\n    }\n    switch (type) {\n      case ReadType.DataURL:\n        fr.readAsDataURL(file)\n        break\n      case ReadType.Text:\n        fr.readAsText(file, encoding)\n        break\n      case ReadType.BinaryString:\n        fr.readAsBinaryString(file)\n        break\n      case ReadType.ArrayBuffer:\n        fr.readAsArrayBuffer(file)\n        break\n    }\n  })\n}\n\nexport const readLocal = Object.assign(_readLocal, {\n  ReadType,\n  /**\n   * 以 data url 读取\n   * @deprecated 已废弃，请使用枚举类 ReadType\n   */\n  DataURL: ReadType.DataURL,\n  /**\n   * 以文本读取\n   * @deprecated 已废弃，请使用枚举类 ReadType\n   */\n  Text: ReadType.Text,\n  /**\n   * 以二进制文件读取\n   * @deprecated 已废弃，请使用枚举类 ReadType\n   */\n  BinaryString: ReadType.BinaryString,\n  /**\n   * 以 ArrayBuffer 读取\n   * @deprecated 已废弃，请使用枚举类 ReadType\n   */\n  ArrayBuffer: ReadType.ArrayBuffer,\n})\n","/**\n * 为 js 中的 Date 对象原型添加 format 格式化方法\n * @param date 要进行格式化的日期\n * @param fmt 日期的格式，格式 {@code '[Y+|y+][M+][D+|d+][H+|h+][m+][s+][S+][q+]'}\n * @returns 格式化得到的结果\n */\nexport function dateFormat(date: Date, fmt: string): string {\n  const timeFormatDefaults = {\n    'Y+|y+': date.getFullYear(),\n    'M+': date.getMonth() + 1, // 月份\n    'D+|d+': date.getDate(), // 日\n    'H+|h+': date.getHours(), // 小时\n    'm+': date.getMinutes(), // 分\n    's+': date.getSeconds(), // 秒\n    'q+': Math.floor((date.getMonth() + 3) / 3), // 季度\n    'S+': date.getMilliseconds(), // 毫秒\n  }\n  for (const k in timeFormatDefaults) {\n    if (!new RegExp('(' + k + ')').test(fmt)) {\n      continue\n    }\n    if (k === 'Y+|y+') {\n      fmt = fmt.replace(\n        RegExp.$1,\n        ('' + timeFormatDefaults[k]).substr(4 - RegExp.$1.length),\n      )\n    } else if (k === 'S+') {\n      let lens = RegExp.$1.length\n      lens = lens === 1 ? 3 : lens\n      fmt = fmt.replace(\n        RegExp.$1,\n        ('00' + timeFormatDefaults[k]).substr(\n          ('' + timeFormatDefaults[k]).length - 1,\n          lens,\n        ),\n      )\n    } else {\n      const v = Reflect.get(timeFormatDefaults, k)\n      fmt = fmt.replace(\n        RegExp.$1,\n        RegExp.$1.length === 1 ? v : ('00' + v).substr(('' + v).length),\n      )\n    }\n  }\n  return fmt\n}\n","import { dateFormat } from '../date/dateFormat'\n\n/**\n * 默认的日期格式\n * 不加 Z 为本地日期时间，避免出现时区的问题\n */\nconst dateFormatter = 'yyyy-MM-ddThh:mm:ss.SSS'\n/**\n * 将参数 key 与 value 进行 url 编码\n * @param k 参数的名字\n * @param v 参数的值\n * @returns 编码后的字符串\n */\nconst encode = (k: string, v: string) =>\n  encodeURIComponent(k) + '=' + encodeURIComponent(v)\n\n/**\n * 拼接参数字符串\n * @param params 参数对象\n * @returns 拼接后的字符串\n */\nexport function spliceParams(params: object = {}): string {\n  return Array.from(Object.entries(params)).reduce((res, [k, v]) => {\n    if (v === undefined || v === null) {\n      return res\n    } else if (v instanceof Date) {\n      res += encode(k, dateFormat(v, dateFormatter))\n    } else if (v instanceof Array) {\n      res += v\n        .map((item) =>\n          encode(\n            k,\n            item instanceof Date ? dateFormat(item, dateFormatter) : item,\n          ),\n        )\n        .join('&')\n    } else {\n      res += encode(k, v)\n    }\n    return (res += '&')\n  }, '')\n}\n","import { ReturnFunc } from '../interface/ReturnFunc'\n\n/**\n * 等待指定的时间/等待指定表达式成立\n * 如果未指定等待条件则立刻执行\n * 注: 此实现在 nodejs 10- 会存在宏任务与微任务的问题，切记 async-await 本质上还是 Promise 的语法糖，实际上并非真正的同步函数！！！即便在浏览器，也不要依赖于这种特性。\n * @param param 等待时间/等待条件\n * @returns Promise 对象\n */\nexport function wait(param?: number | ReturnFunc<boolean>): Promise<void> {\n  return new Promise((resolve) => {\n    if (typeof param === 'number') {\n      setTimeout(resolve, param)\n    } else if (typeof param === 'function') {\n      const timer = setInterval(() => {\n        if (param()) {\n          clearInterval(timer)\n          resolve()\n        }\n      }, 100)\n    } else {\n      resolve()\n    }\n  })\n}\n","import { wait } from '../async/wait'\n\n/**\n * 为 fetch 请求添加超时选项\n * 注：超时选项并非真正意义上的超时即取消请求，请求依旧正常执行完成，但会提前返回 reject 结果\n * @param fetchPromise fetch 请求的 Promise\n * @param timeout 超时时间\n * @returns 如果超时就提前返回 reject, 否则正常返回 fetch 结果\n */\nexport function fetchTimeout<R>(\n  fetchPromise: Promise<R>,\n  timeout: number,\n): Promise<R> {\n  return Promise.race([\n    fetchPromise,\n    wait(timeout).then(() => {\n      throw new Error('timeout')\n    }),\n  ])\n}\n","/**\n * 将字符串转为字符流\n * @param str 字符串\n * @returns 字符流对象\n */\nexport function strToArrayBuffer(str: string): ArrayBuffer {\n  const buf = new ArrayBuffer(str.length)\n  const view = new Uint8Array(buf)\n  for (let i = 0; i < str.length; ++i) {\n    view[i] = str.charCodeAt(i) & 0xff\n  }\n  return buf\n}\n","import { wait } from '../async/wait'\nimport { fetchTimeout } from './fetchTimeout'\n\n/**\n * Fetch 对象参数接口\n */\ninterface IFetchLimitingOptions {\n  timeout: number\n  limit: number\n}\n\n/**\n * 限制并发请求数量的 fetch 封装\n * @class FetchLimiting\n * @example\n * const fetchLimiting = new FetchLimiting()\n * fetchLimiting._fetch('/')\n *   .then(res => res.json())\n *   .then(json => console.log(json))\n * @deprecated 已废弃，请使用 {@link asyncLimiting} 函数\n */\nexport class FetchLimiting {\n  private timeout: number\n  private limit: number\n  private execCount: number\n  private waitArr: Array<[RequestInfo, RequestInit | undefined]>\n  /**\n   * 构造函数\n   * @param option 可选配置项\n   * @param option.timeout 超时毫秒数\n   * @param option.limit 最大并发数限制\n   */\n  constructor({\n    timeout = 10000,\n    limit = 10,\n  }: Partial<IFetchLimitingOptions> = {}) {\n    /**\n     * @field timeout 超时毫秒数\n     */\n    this.timeout = timeout\n    /**\n     * @field limit 最大并发数限制\n     */\n    this.limit = limit\n    /**\n     * @field execCount 当前正在执行异步的数量\n     */\n    this.execCount = 0\n    /**\n     * @field waitArr 等待的队列\n     * @type {Array.<IArguments>}\n     */\n    this.waitArr = []\n  }\n\n  /**\n   * 执行一个请求\n   * 如果到达最大并发限制时就进行等待\n   * @param url 请求 url 信息\n   * @param init 请求的其他可选项，默认为 undefined\n   * @returns 如果超时就提前返回 reject, 否则正常返回 fetch 结果\n   */\n  public async fetch(\n    input: RequestInfo,\n    init?: RequestInit,\n  ): Promise<Response> {\n    const _innerFetch = async () => {\n      this.execCount++\n      const args = this.waitArr.shift()\n      try {\n        // 这里的 args 实际上就是 arguments 对象，即上面的 url 和 init\n        return await fetchTimeout(fetch(args![0], args![1]), this.timeout)\n      } finally {\n        this.execCount--\n      }\n    }\n    this.waitArr.push([input, init])\n    await wait(() => this.execCount < this.limit)\n    // 尝试启动等待队列\n    return _innerFetch()\n  }\n}\n","/**\n * 将一个 Iterator 迭代器转换为一个 Array\n * @param iterator Iterator 迭代器\n * @return Iterator 中每一项元素转换而得到的 Array\n * @deprecated 已废弃，请使用 ES6 原生函数 {@see Array.from} 替代\n */\nexport function asIterator<T>(iterator: Iterator<T>): T[] {\n  const arr = []\n  while (true) {\n    const next = iterator.next()\n    if (next.done) {\n      break\n    }\n    arr.push(next.value)\n  }\n  return arr\n}\n","/**\n * 判断一个对象是否是无效的\n * 无效的值仅包含 null/undefined\n * @param object 任何一个对象\n * @returns 是否无效的值\n */\nexport function isNullOrUndefined(object: any): object is null | undefined {\n  return object === undefined || object === null\n}\n","/**\n * 返回第一个参数的函数\n * 注: 一般可以当作返回参数自身的函数，如果你只关注第一个参数的话\n * @param obj 任何对象\n * @typeparam T 传入参数的类型\n * @typeparam R 返回结果的类型，默认为 T，只是为了兼容该函数当参数被传递时可能出现需要类型不一致的问题\n * @returns 传入的第一个参数\n */\nexport function returnItself<T, R = T>(obj: T): R {\n  return obj as any\n}\n","/**\n * 兼容异步函数的返回值\n * @param res 返回值\n * @param callback 同步/异步结果的回调函数\n * @typeparam T 处理参数的类型，如果是 Promise 类型，则取出其泛型类型\n * @typeparam Param 处理参数具体的类型，如果是 Promise 类型，则指定为原类型\n * @typeparam R 返回值具体的类型，如果是 Promise 类型，则指定为 Promise 类型，否则为原类型\n * @returns 处理后的结果，如果是同步的，则返回结果是同步的，否则为异步的\n */\nexport function compatibleAsync<T = any, Param = T | Promise<T>, R = T>(\n  res: Param,\n  callback: (r: T) => R,\n): Param extends Promise<T> ? Promise<R> : R {\n  return (res instanceof Promise\n    ? res.then(callback)\n    : callback(res as any)) as any\n}\n","import { ReturnFunc } from '../interface/ReturnFunc'\nimport { compatibleAsync } from '../async/compatibleAsync'\n\n/**\n * 谓词的返回值，支持异步函数\n */\ntype PredicateReturn = boolean | Promise<boolean>\n/**\n * 谓词函数的类型\n */\ntype PredicateFunc = ReturnFunc<PredicateReturn>\n\n/**\n * 内部使用的函数\n * 注: 如果谓词中包含任意一个异步(返回 Promise)函数,则整个返回结果将变成异步的,否则默认为同步操作.\n * @param fns 谓词数组\n * @param args 谓词应用的参数列表\n * @param condition 临界条件\n * @returns 返回结果\n */\nfunction _inner(\n  fns: PredicateFunc[],\n  args: any[],\n  condition: (res: boolean) => boolean,\n): PredicateReturn {\n  const fn = fns[0]\n  const res = fn!(...args)\n  function _call(res: boolean): PredicateReturn {\n    if (condition(res)) {\n      return res\n    }\n    const others = fns.slice(1)\n    if (others.length === 0) {\n      return res\n    }\n    return _inner(others, args, condition)\n  }\n  return compatibleAsync(res, _call) as any\n}\n\n/**\n * 连接谓词函数\n */\nexport class CombinedPredicate {\n  /**\n   * 使用 && 进行连接\n   * @param fns 连接任意多个谓词\n   * @returns 连接后的新谓词\n   */\n  public static and(...fns: PredicateFunc[]) {\n    return function (...args: any[]) {\n      return _inner(fns, args, (res) => !res)\n    }\n  }\n  /**\n   * 使用 || 进行连接\n   * @param fns 连接任意多个谓词\n   * @returns 连接后的新谓词\n   */\n  public static or(...fns: PredicateFunc[]) {\n    return function (...args: any[]) {\n      return _inner(fns, args, (res) => res)\n    }\n  }\n  /**\n   * 对谓词进行取反\n   * @param fn 谓词\n   * @returns 取反后的谓词\n   */\n  public static not(fn: PredicateFunc) {\n    return new Proxy(fn, {\n      apply(_, _this, args) {\n        return compatibleAsync(Reflect.apply(_, this, args), (res) => !res)\n      },\n    })\n  }\n}\n\nexport const and = CombinedPredicate.and\nexport const or = CombinedPredicate.or\nexport const not = CombinedPredicate.not\n","import { isNullOrUndefined } from '../obj/isNullOrUndefined'\nimport { returnItself } from '../function/returnItself'\nimport { CombinedPredicate } from '../function/CombinedPredicate'\n\n/**\n * 操作类型\n */\nenum ActionType {\n  forEach = 'forEach',\n  filter = 'filter',\n  map = 'map',\n  flatMap = 'flatMap',\n  sort = 'sort',\n  reduce = 'reduce',\n  reduceRight = 'reduceRight',\n  findIndex = 'findIndex',\n  find = 'find',\n  every = 'every',\n  some = 'some',\n  parallel = 'parallel',\n  serial = 'serial',\n}\n/**\n * 保存高阶函数传入的异步操作\n * @field 异步操作的类型\n * @field 异步操作\n */\nclass Action {\n  public static Type = ActionType\n  constructor(public readonly type: ActionType, public readonly args: any[]) {\n    this.type = type\n    this.args = args\n  }\n}\n\n/**\n * 异步的 reduce 回调函数类型\n */\ntype AsyncArrayReduceCallback<T, R, IArray> = (\n  res: R,\n  item: T,\n  index: number,\n  arr: IArray,\n) => Promise<R>\n/**\n * 异步的数组一般迭代类型\n */\ntype AsyncArrayCallback<T, R, IArray> = (\n  item: T,\n  index: number,\n  arr: IArray,\n) => Promise<R>\n\n/**\n * 抽象异步数组，实现了一些公共的函数\n */\nabstract class InnerBaseAsyncArray<T> {\n  /**\n   * 内部的数组\n   */\n  protected _arr: T[]\n  /**\n   * 构造函数\n   * @param args 数组初始元素\n   */\n  constructor(args: T[] = []) {\n    this._arr = args\n  }\n  /**\n   * 异步的 forEach\n   * @param fn 异步迭代函数\n   */\n  public abstract async forEach(\n    fn: AsyncArrayCallback<T, void, any>,\n  ): Promise<void>\n  /**\n   * 异步的 filter\n   * @param fn 异步过滤函数\n   * @returns 过滤后的新数组\n   */\n  public abstract async filter(\n    fn: AsyncArrayCallback<T, boolean, any>,\n  ): Promise<any>\n  /**\n   * 异步的 map\n   * @param fn 异步映射函数\n   * @returns 经过映射产生的新的异步数组\n   */\n  public abstract async map<R>(fn: AsyncArrayCallback<T, R, any>): Promise<any>\n  /**\n   * 异步的 flatMap\n   * @param fn 异步映射函数，产生一个新的数组\n   * @returns 压平一层的数组\n   */\n  public abstract async flatMap<R>(\n    fn: AsyncArrayCallback<T, R[], any>,\n  ): Promise<any>\n  /**\n   * 将整个数组排序\n   * @param fn 比较函数\n   * @returns 排序后的数组\n   */\n  public async sort(\n    fn?: (t1: T, t2: T) => Promise<number>,\n  ): Promise<InnerAsyncArray<T>> {\n    if (fn === undefined) {\n      return new InnerAsyncArray(this._arr.sort())\n    }\n    // TODO 此处为了让 type-doc 能生成文档而不得不加上类型\n    const arr: Array<[T, number]> = this._arr.map(\n      (v, i) => [v, i] as [T, number],\n    )\n    async function _sort<V>(\n      arr: V[],\n      fn: (v1: V, v2: V) => Promise<number>,\n    ): Promise<V[]> {\n      // 边界条件，如果传入数组的值\n      if (arr.length <= 1) {\n        return arr\n      }\n      // 根据中间值对数组分治为两个数组\n      const medianIndex = Math.floor(arr.length / 2)\n      const medianValue = arr[medianIndex]\n      const left = []\n      const right = []\n      for (let i = 0, len = arr.length; i < len; i++) {\n        if (i === medianIndex) {\n          continue\n        }\n        const v = arr[i]\n        if ((await fn(v, medianValue)) <= 0) {\n          left.push(v)\n        } else {\n          right.push(v)\n        }\n      }\n      return (await _sort(left, fn))\n        .concat([medianValue])\n        .concat(await _sort(right, fn))\n    }\n    return new InnerAsyncArray<T>(\n      await (await _sort(arr, ([t1], [t2]) => fn(t1, t2))).map(\n        ([_v, i]) => this._arr[i],\n      ),\n    )\n  }\n  /**\n   * 异步的 reduce\n   * @param fn 归纳函数\n   * @param res 初始值，默认为第一个元素\n   * @returns 归纳后的值\n   */\n  public abstract async reduce<R = T>(\n    fn: AsyncArrayReduceCallback<T, R, any>,\n    res?: R,\n  ): Promise<R>\n  /**\n   * 异步的 reduceRight\n   * @param fn 归纳函数\n   * @param res 初始值，默认为最后一个元素\n   * @returns 归纳后的值\n   */\n  public abstract async reduceRight<R = T>(\n    fn: AsyncArrayReduceCallback<T, R, any>,\n    res?: R,\n  ): Promise<R>\n  /**\n   * 异步 findIndex\n   * @param fn 异步查询函数\n   * @returns 查询到的第一个值的下标\n   */\n  public abstract async findIndex(\n    fn: AsyncArrayCallback<T, boolean, any>,\n  ): Promise<number>\n  /**\n   * 异步的 find\n   * @param fn 异步查询函数\n   * @returns 查询到的第一个值\n   */\n  public async find(\n    fn: AsyncArrayCallback<T, boolean, any>,\n  ): Promise<T | null> {\n    const i = await this.findIndex(fn)\n    return i === -1 ? null : this._arr[i]\n  }\n  /**\n   * 异步的 every\n   * @param fn 异步匹配函数\n   * @returns 是否全部匹配\n   */\n  public async every(\n    fn: AsyncArrayCallback<T, boolean, any>,\n  ): Promise<boolean> {\n    return (await this.findIndex(CombinedPredicate.not(fn) as any)) === -1\n  }\n  /**\n   * 异步的 some\n   * @param fn 异步匹配函数\n   * @returns 是否有任意一个匹配\n   */\n  public async some(fn: AsyncArrayCallback<T, boolean, any>): Promise<boolean> {\n    return (await this.findIndex(fn)) !== -1\n  }\n  /**\n   * 转换为并发异步数组\n   */\n  public parallel(): any {\n    return new InnerAsyncArrayParallel(this._arr)\n  }\n  /**\n   * 转换为顺序异步数组\n   */\n  public serial(): any {\n    return new InnerAsyncArray(this._arr)\n  }\n  /**\n   * 获取内部数组的值，将返回一个浅复制的数组\n   */\n  public value(): T[] {\n    return this._arr.slice()\n  }\n}\n\n/**\n * 串行的异步数组\n */\nclass InnerAsyncArray<T> extends InnerBaseAsyncArray<T> {\n  constructor(args?: T[]) {\n    super(args)\n  }\n  public async forEach(\n    fn: AsyncArrayCallback<T, void, InnerAsyncArray<T>>,\n  ): Promise<void> {\n    for (let i = 0, len = this._arr.length; i < len; i++) {\n      await fn.call(this, this._arr[i], i, this)\n    }\n  }\n  public async filter(\n    fn: AsyncArrayCallback<T, boolean, InnerAsyncArray<T>>,\n  ): Promise<InnerAsyncArray<T>> {\n    const res = new InnerAsyncArray<T>()\n    for (let i = 0, len = this._arr.length; i < len; i++) {\n      if (await fn.call(this, this._arr[i], i, this)) {\n        res._arr.push(this._arr[i])\n      }\n    }\n    return res\n  }\n  public async map<R>(\n    fn: AsyncArrayCallback<T, R, InnerAsyncArray<T>>,\n  ): Promise<InnerAsyncArray<R>> {\n    const res = new InnerAsyncArray<R>()\n    for (let i = 0, len = this._arr.length; i < len; i++) {\n      res._arr.push(await fn.call(this, this._arr[i], i, this))\n    }\n    return res\n  }\n  public async flatMap<R>(\n    fn: AsyncArrayCallback<T, R[], InnerAsyncArray<T>>,\n  ): Promise<InnerAsyncArray<R>> {\n    const res = new InnerAsyncArray<R>()\n    for (let i = 0, len = this._arr.length; i < len; i++) {\n      res._arr.push(...(await fn.call(this, this._arr[i], i, this)))\n    }\n    return res\n  }\n  public async reduce<R = T>(\n    fn: AsyncArrayReduceCallback<T, R, InnerAsyncArray<T>>,\n    res?: R,\n  ): Promise<R> {\n    for (let i = 0, len = this._arr.length; i < len; i++) {\n      if (res) {\n        res = await fn.call(this, res, this._arr[i], i, this)\n      } else {\n        res = this._arr[i] as any\n      }\n    }\n    return res as any\n  }\n  public async reduceRight<R = T>(\n    fn: AsyncArrayReduceCallback<T, R, InnerAsyncArray<T>>,\n    res?: R,\n  ): Promise<R> {\n    for (let i = this._arr.length - 1; i >= 0; i--) {\n      if (res) {\n        res = await fn.apply(this, [res, this._arr[i], i, this])\n      } else {\n        res = this._arr[i] as any\n      }\n    }\n    return res as any\n  }\n  public async findIndex(\n    fn: AsyncArrayCallback<T, boolean, InnerAsyncArray<T>>,\n  ): Promise<number> {\n    for (let i = 0, len = this._arr.length; i < len; i++) {\n      const res = await fn.call(this, this._arr[i], i, this)\n      if (res) {\n        return i\n      }\n    }\n    return -1\n  }\n}\n\n/**\n * 并发的异步数组\n */\nclass InnerAsyncArrayParallel<T> extends InnerBaseAsyncArray<T> {\n  constructor(args?: T[]) {\n    super(args)\n  }\n  public async forEach(\n    fn: AsyncArrayCallback<T, void, InnerAsyncArrayParallel<T>>,\n  ): Promise<void> {\n    await this._all(fn)\n  }\n  public async filter(\n    fn: AsyncArrayCallback<T, boolean, InnerAsyncArrayParallel<T>>,\n  ): Promise<InnerAsyncArrayParallel<T>> {\n    const res = await this._all(fn)\n    const result = new InnerAsyncArrayParallel<T>()\n    for (let i = 0, len = res.length; i < len; i++) {\n      if (res[i]) {\n        result._arr.push(this._arr[i])\n      }\n    }\n    return result\n  }\n  public async map<R>(\n    fn: AsyncArrayCallback<T, R, InnerAsyncArrayParallel<T>>,\n  ): Promise<InnerAsyncArrayParallel<R>> {\n    return new InnerAsyncArrayParallel(await this._all(fn))\n  }\n  public async flatMap<R>(\n    fn: AsyncArrayCallback<T, R[], InnerAsyncArrayParallel<T>>,\n  ): Promise<InnerAsyncArrayParallel<R>> {\n    const res = await this._all(fn)\n    return new InnerAsyncArrayParallel(res.flat())\n  }\n  public sort(\n    fn: (t1: T, t2: T) => Promise<number>,\n  ): Promise<InnerAsyncArray<T>> {\n    throw new Error('Method not implemented.')\n  }\n  public async reduce<R = T>(\n    fn: AsyncArrayReduceCallback<T, R, InnerAsyncArrayParallel<T>>,\n    res?: R,\n  ): Promise<R> {\n    for (let i = 0, len = this._arr.length; i < len; i++) {\n      if (res) {\n        res = await fn.call(this, res, this._arr[i], i, this)\n      } else {\n        res = this._arr[i] as any\n      }\n    }\n    return res as any\n  }\n  public async reduceRight<R = T>(\n    fn: AsyncArrayReduceCallback<T, R, InnerAsyncArrayParallel<T>>,\n    res?: R,\n  ): Promise<R> {\n    for (let i = this._arr.length - 1; i >= 0; i--) {\n      if (res) {\n        res = await fn.apply(this, [res, this._arr[i], i, this])\n      } else {\n        res = this._arr[i] as any\n      }\n    }\n    return res as any\n  }\n  public async findIndex(\n    fn: AsyncArrayCallback<T, boolean, InnerAsyncArrayParallel<T>>,\n  ): Promise<number> {\n    return (await this._all(fn)).findIndex(returnItself)\n  }\n  private async _all<R>(\n    fn: AsyncArrayCallback<T, R, InnerAsyncArrayParallel<T>>,\n  ): Promise<R[]> {\n    return await Promise.all(\n      this._arr.map((v, i) => fn.apply(this, [v, i, this])),\n    )\n  }\n}\n/**\n * 异步数组\n */\nexport class AsyncArray<T> implements PromiseLike<any> {\n  /**\n   * 为内置数组赋值\n   * 此处自动重新计算 length 属性\n   */\n  public set _arr(arr: T[]) {\n    this.__arr = arr\n    this.length = this.__arr.length\n  }\n  public get _arr() {\n    return this.__arr\n  }\n  /**\n   * 提供一个函数方便根据已有的数组或类数组（Set/Map）创建 {@link AsyncArray}\n   * @param arr 一个可迭代元素\n   * @returns 创建一个新的异步数组包装\n   */\n  public static from<T>(\n    arr: Iterable<T> | ArrayLike<T> | null | undefined,\n  ): AsyncArray<T> {\n    const result = new AsyncArray<T>()\n    if (isNullOrUndefined(arr)) {\n      return result\n    }\n    result._arr = Array.from(arr)\n    return result\n  }\n  /**\n   * 内部数组的长度，用于让 {@link AsyncArray} 的实例能作为 {@link Array.from} 的参数\n   */\n  public length = 0\n  /**\n   * 内部的数组\n   */\n  private __arr!: T[]\n  /**\n   * 保存的任务数组\n   */\n  private _tasks: Action[]\n  /**\n   * 构造函数\n   * @param args 任意个参数\n   */\n  constructor(...args: T[]) {\n    this._arr = Array.from(args)\n    /**\n     * @field 保存异步任务\n     * @type {Action[]}\n     */\n    this._tasks = []\n  }\n  public filter(\n    fn: AsyncArrayCallback<\n      T,\n      boolean,\n      InnerAsyncArray<T> | InnerAsyncArrayParallel<T>\n    >,\n  ): AsyncArray<T> {\n    return this._addTask(new Action(Action.Type.filter, [fn]))\n  }\n  public map<R>(\n    fn: AsyncArrayCallback<\n      T,\n      R,\n      InnerAsyncArray<T> | InnerAsyncArrayParallel<T>\n    >,\n  ): AsyncArray<R> {\n    return this._addTask(new Action(Action.Type.map, [fn])) as any\n  }\n  public flatMap<R>(\n    fn: AsyncArrayCallback<\n      T,\n      R[],\n      InnerAsyncArray<T> | InnerAsyncArrayParallel<T>\n    >,\n  ): AsyncArray<R> {\n    return this._addTask(new Action(Action.Type.flatMap, [fn])) as any\n  }\n  public sort(fn?: (a: T, b: T) => number): AsyncArray<T> {\n    return this._addTask(new Action(Action.Type.sort, [fn]))\n  }\n  public parallel(): AsyncArray<T> {\n    return this._addTask(new Action(Action.Type.parallel, []))\n  }\n  public serial(): AsyncArray<T> {\n    return this._addTask(new Action(Action.Type.serial, []))\n  }\n  public forEach(\n    fn: AsyncArrayCallback<\n      T,\n      void,\n      InnerAsyncArray<T> | InnerAsyncArrayParallel<T>\n    >,\n  ): Promise<void> {\n    return this._addTask(new Action(Action.Type.forEach, [fn])).then()\n  }\n  public some(\n    fn: AsyncArrayCallback<\n      T,\n      boolean,\n      InnerAsyncArray<T> | InnerAsyncArrayParallel<T>\n    >,\n  ): Promise<boolean> {\n    return this._addTask(new Action(Action.Type.some, [fn])).then()\n  }\n  public every(\n    fn: AsyncArrayCallback<\n      T,\n      boolean,\n      InnerAsyncArray<T> | InnerAsyncArrayParallel<T>\n    >,\n  ): Promise<boolean> {\n    return this._addTask(new Action(Action.Type.every, [fn])).then()\n  }\n  public find(\n    fn: AsyncArrayCallback<\n      T,\n      boolean,\n      InnerAsyncArray<T> | InnerAsyncArrayParallel<T>\n    >,\n  ): Promise<T | null> {\n    return this._addTask(new Action(Action.Type.find, [fn])).then()\n  }\n  public findIndex(\n    fn: AsyncArrayCallback<\n      T,\n      boolean,\n      InnerAsyncArray<T> | InnerAsyncArrayParallel<T>\n    >,\n  ): Promise<number> {\n    return this._addTask(new Action(Action.Type.findIndex, [fn])).then()\n  }\n  public reduce<R = T>(\n    fn: AsyncArrayReduceCallback<T, R, InnerAsyncArray<T>>,\n    res?: R,\n  ): Promise<R> {\n    return this._addTask(new Action(Action.Type.reduce, [fn, res])).then()\n  }\n  public reduceRight<R = T>(\n    fn: AsyncArrayReduceCallback<T, R, InnerAsyncArray<T>>,\n    res?: R,\n  ): Promise<R> {\n    return this._addTask(new Action(Action.Type.reduceRight, [fn, res])).then()\n  }\n  /**\n   * 终结整个链式操作并返回结果，可以使用 await 等待当前实例开始计算\n   */\n  public async then<TResult1 = any, TResult2 = never>(\n    onfulfilled?:\n      | ((value: any) => TResult1 | PromiseLike<TResult1>)\n      | undefined\n      | null,\n    onrejected?:\n      | ((reason: any) => TResult2 | PromiseLike<TResult2>)\n      | undefined\n      | null,\n  ): Promise<any> {\n    try {\n      let asyncArray = new InnerAsyncArray(this._arr)\n      let result: any = this._arr\n      for (const task of this._tasks) {\n        asyncArray = await Reflect.apply(\n          Reflect.get(asyncArray, task.type),\n          asyncArray,\n          task.args,\n        )\n        if (asyncArray instanceof InnerBaseAsyncArray) {\n          result = asyncArray.value()\n        } else {\n          if (!isNullOrUndefined(onfulfilled)) {\n            onfulfilled(result)\n          }\n          return asyncArray\n        }\n      }\n      if (!isNullOrUndefined(onfulfilled)) {\n        onfulfilled(result)\n      }\n      return result\n    } catch (err) {\n      if (!isNullOrUndefined(onrejected)) {\n        onrejected(err)\n      }\n    }\n  }\n  /**\n   * @deprecated 已废弃，请直接使用 await 进行等待获取结果值即可\n   */\n  public value(): Promise<any> {\n    return this.then()\n  }\n  /**\n   * 允许使用 for-of 遍历内部的 _arr\n   */\n  public *[Symbol.iterator]() {\n    for (const kv of this._arr) {\n      yield kv\n    }\n  }\n  private _addTask(task: Action): AsyncArray<T> {\n    const result = new AsyncArray(...this._arr)\n    result._tasks = [...this._tasks, task]\n    return result\n  }\n}\n","/**\n * 将数组异步压平一层\n * @param arr 数组\n * @param fn 映射函数，将一个元素映射为一个数组\n * @returns 压平一层的数组\n * @deprecated 已废弃，请使用更强大的异步数组 {@link AsyncArray}\n */\nimport { AsyncArray } from './AsyncArray'\n\nexport async function asyncFlatMap<T>(\n  arr: T[],\n  fn: (item: T, index: number, arr: T[]) => Promise<T[]>,\n): Promise<T[]> {\n  return new AsyncArray(...arr).flatMap(fn as any)\n}\n","/**\n * 判断数字是否在指定区间之中\n * @param num 指定数字\n * @param min 最小值\n * @param max 最大值（不包含）\n */\nexport function isRange(num: number, min: number, max: number): boolean {\n  return num >= min && num < max\n}\n","import { isNullOrUndefined } from '../obj/isNullOrUndefined'\nimport { isRange } from '../number/isRange'\n\n/**\n * 判断是否为小数的正则表达式\n */\nconst FloatRule = /^(-?\\d+)(.\\d+)?$/\n/**\n * 判断是否为整数的正则表达式\n */\nconst IntegerRule = /^-?\\d+$/\n/**\n * 判断是否为邮箱的正则表达式\n */\nconst EmailRule = /^\\w+((-\\w+)|(\\.\\w+))*@[A-Za-z0-9]+((\\.|-)[A-Za-z0-9]+)*\\.[A-Za-z]+$/\n/**\n * 判断是否为 ipv4 地址的正则表达式\n */\nconst Ipv4Rule = /^((25[0-5]|2[0-4]\\d|1?\\d?\\d)\\.){3}(25[0-5]|2[0-4]\\d|1?\\d?\\d)$/\n/**\n * 判断是否为固定电话的正则表达式\n */\nconst TelephoneRule = /^0[1-9][0-9]{1,2}-[2-8][0-9]{6,7}$/\n/**\n * 判断是否为移动电话的正则表达式\n * 注：不在判断二三位的数字，具体参考：http://caibaojian.com/phone-regexp.html\n */\nconst MobileRule = /^1\\d{10}$/\n/**\n * 判断是否为域名的正则表达式\n */\nconst DomainRule = /^(?=^.{3,255}$)[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(\\.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+$/\n/**\n * 判断是否为邮政编码的正则表达式\n */\nconst PostcodeRule = /^\\d{6}$/\n\ntype IString = string | null | undefined\n\n/**\n * 字符串校验\n * @suppress 之后将会对类型定义进行不兼容修改，避免一直出现的两难问题\n */\nexport class StringValidator {\n  /**\n   * 判断一个字符串是否为空字符串\n   * @param str 字符串\n   * @returns 是否为空字符串\n   */\n  public static isEmpty(str: IString): str is string {\n    return isNullOrUndefined(str) || str === ''\n  }\n  /**\n   * 判断一个字符串是否为空白的字符串\n   * @param str 字符串\n   * @returns 是否为空字符串\n   */\n  public static isBlank(str: IString): str is string {\n    return StringValidator.isEmpty(str) || str!.trim() === ''\n  }\n\n  /**\n   * 判断字符串是否位小数\n   * @param str 需要进行判断的字符串\n   * @returns 是否为小数\n   */\n  public static isFloat(str: IString): str is string {\n    if (isNullOrUndefined(str)) {\n      return false\n    }\n    return FloatRule.test(str)\n  }\n\n  /**\n   * 判断字符串是否位整数\n   * @param str 需要进行判断的字符串\n   * @returns 是否为小数\n   */\n  public static isInteger(str: IString): str is string {\n    return !isNullOrUndefined(str) && IntegerRule.test(str)\n  }\n  /**\n   * 判断邮箱的格式是否正确\n   * @param str 邮箱字符串\n   * @returns 是否是邮箱\n   */\n  public static isEmail(str: IString): str is string {\n    return !isNullOrUndefined(str) && EmailRule.test(str)\n  }\n  /**\n   * 判断 ipv4 地址的格式是否正确\n   * @param str ipv4 字符串\n   * @returns 是否是 ipv4 地址\n   */\n  public static isIpv4(str: IString): str is string {\n    return !isNullOrUndefined(str) && Ipv4Rule.test(str)\n  }\n  /**\n   * 判断字符串是否为正确的端口号\n   * 正确的端口号是 1-65535\n   * @param str 字符串\n   * @returns 是否为端口号\n   */\n  public static isPort(str: IString): str is string {\n    // tslint:disable-next-line:radix\n    return StringValidator.isInteger(str) && isRange(parseInt(str), 1, 65535)\n  }\n  /**\n   * 判断是否为固定电话\n   * @param str 字符串\n   * @returns 是否为固定电话\n   */\n  public static isTelephone(str: IString): str is string {\n    return !isNullOrUndefined(str) && TelephoneRule.test(str)\n  }\n  /**\n   * 判断是否为移动电话\n   * @param str 字符串\n   * @returns 是否为移动电话\n   */\n  public static isMobile(str: IString): str is string {\n    return !isNullOrUndefined(str) && MobileRule.test(str)\n  }\n  /**\n   * 判断是否为域名\n   * @param str 字符串\n   * @returns 是否为域名\n   */\n  public static isDomain(str: IString): str is string {\n    return !isNullOrUndefined(str) && DomainRule.test(str)\n  }\n  /**\n   * 判断是否为邮政编码\n   * @param str 字符串\n   * @returns 是否为邮政编码\n   */\n  public static isPostcode(str: IString): str is string {\n    return !isNullOrUndefined(str) && PostcodeRule.test(str)\n  }\n}\n\n/**\n * 导出一个字符串校验的对象\n * @deprecated 已废弃，请直接使用类的静态函数\n */\nexport const stringValidator = StringValidator\n","import { StringValidator } from '../string/StringValidator'\n\n/**\n * 可能的类型\n */\nenum Type {\n  String,\n  Number,\n  Boolean,\n  Undefined,\n  Null,\n  Symbol,\n  PropertyKey,\n  Object,\n  Array,\n  Function,\n  Date,\n  File,\n  Blob,\n  Stream,\n  ArrayBuffer,\n  ArrayBufferView,\n  URLSearchParams,\n  FormData,\n}\n/**\n * 校验变量的类型\n */\nexport class TypeValidator {\n  /**\n   * 类型枚举类对象\n   */\n  public static Type = Type\n  /**\n   * 获取变量的类型\n   * @param val 变量\n   * @returns 类型\n   * 注: 此函数依赖于 ts 的编译枚举原理与约定 {@link TypeValidator} 中所有判断函数都是以 `is` 开头并于 {@link Type} 中的保持一致\n   */\n  public static getType(val: any): Type {\n    for (const k of Object.keys(Type)) {\n      if (StringValidator.isInteger(k)) {\n        const type = Type[k as any]\n        if ((TypeValidator as any)['is' + type](val)) {\n          return Type[type as any] as any\n        }\n      }\n    }\n    throw new Error('无法识别的类型')\n  }\n  /**\n   * 判断是否为指定类型\n   * @param val 需要判断的值\n   * @param types 需要判断的类型\n   */\n  public static isType(val: any, ...types: Type[]): boolean {\n    return types.includes(TypeValidator.getType(val))\n  }\n  /**\n   * 判断是否为字符串\n   * @param val 需要判断的值\n   * @returns 是否为字符串\n   */\n  public static isString(val: any): val is string {\n    return typeof val === 'string'\n  }\n  /**\n   * 判断是否为数字\n   * @param val 需要判断的值\n   * @returns 是否为数字\n   */\n  public static isNumber(val: any): val is number {\n    return typeof val === 'number'\n  }\n  /**\n   * 判断是否为布尔值\n   * @param val 需要判断的值\n   * @returns 是否为布尔值\n   */\n  public static isBoolean(val: any): val is boolean {\n    return typeof val === 'boolean'\n  }\n  /**\n   * 判断是否为 Symbol\n   * @param val 需要判断的值\n   * @returns 是否为 Symbol\n   */\n  public static isSymbol(val: any): val is symbol {\n    return typeof val === 'symbol'\n  }\n  /**\n   * 判断是否为 undefined\n   * @param val 需要判断的值\n   * @returns 是否为 undefined\n   */\n  public static isUndefined(val: any): val is undefined {\n    return val === undefined\n  }\n  /**\n   * 判断是否为 null\n   * @param val 需要判断的值\n   * @returns 是否为 null\n   */\n  public static isNull(val: any): val is null {\n    return val === null\n  }\n  /**\n   * 判断是否可以作为对象的属性\n   * @param val 需要判断的值\n   * @returns 是否为对象属性\n   */\n  public static isPropertyKey(val: any): val is PropertyKey {\n    return (\n      TypeValidator.isString(val) ||\n      TypeValidator.isNumber(val) ||\n      TypeValidator.isSymbol(val)\n    )\n  }\n  /**\n   * 判断是否为对象\n   * 注: 函数（包括 ES6 箭头函数）将不被视为对象\n   * @param val 需要判断的值\n   * @returns 是否为对象\n   */\n  public static isObject(val: any): val is Object {\n    return (\n      !TypeValidator.isNull(val) &&\n      !TypeValidator.isUndefined(val) &&\n      typeof val === 'object'\n    )\n  }\n  /**\n   * 判断是否为数组\n   * @param val 需要判断的值\n   * @returns 是否为数组\n   */\n  public static isArray(val: any): val is any[] {\n    return Array.isArray(val)\n  }\n  /**\n   * 判断是否为数组\n   * @param val 需要判断的值\n   * @returns 是否为数组\n   */\n  public static isFunction(val: any): val is Function {\n    return toString.call(val) === '[object Function]'\n  }\n  /**\n   * 判断是否为日期\n   * @param val 需要判断的值\n   * @returns 是否为日期\n   */\n  public static isDate(val: any): val is Date {\n    return toString.call(val) === '[object Date]'\n  }\n  /**\n   * 判断是否为浏览器文件类型\n   * @param val 需要判断的值\n   * @returns 是否为浏览器文件类型\n   */\n  public static isFile(val: any): val is File {\n    return toString.call(val) === '[object File]'\n  }\n  /**\n   * 判断是否为浏览器二进制类型\n   * @param val 需要判断的值\n   * @returns 是否为浏览器二进制类型\n   */\n  public static isBlob(val: any): val is Blob {\n    return toString.call(val) === '[object Blob]'\n  }\n  /**\n   * 判断是否为浏览器流类型\n   * @param val 需要判断的值\n   * @returns 是否为浏览器流类型\n   */\n  public static isStream(val: any): boolean {\n    return TypeValidator.isObject(val) && TypeValidator.isFunction(val.pipe)\n  }\n  /**\n   * 判断是否为浏览器 ArrayBuffer 类型\n   * @param val 需要判断的值\n   * @returns 是否为浏览器 ArrayBuffer 类型\n   */\n  public static isArrayBuffer(val: any): val is ArrayBuffer {\n    return toString.call(val) === '[object ArrayBuffer]'\n  }\n  /**\n   * 判断是否为浏览器 ArrayBufferView 类型\n   * @param val 需要判断的值\n   * @returns 是否为浏览器 ArrayBufferView 类型\n   */\n  public static isArrayBufferView(val: any): val is ArrayBufferView {\n    return typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView\n      ? ArrayBuffer.isView(val)\n      : val && val.buffer && val.buffer instanceof ArrayBuffer\n  }\n  /**\n   * 判断是否为浏览器 URLSearchParams 类型\n   * @param val 需要判断的值\n   * @returns 是否为浏览器 URLSearchParams 类型\n   */\n  public static isURLSearchParams(val: any): val is URLSearchParams {\n    return !TypeValidator.isUndefined(val) && val instanceof URLSearchParams\n  }\n  /**\n   * 判断是否为浏览器 FormData 类型\n   * @param val 需要判断的值\n   * @returns 是否为浏览器 FormData 类型\n   */\n  public static isFormData(val: any): val is FormData {\n    return !TypeValidator.isUndefined(val) && val instanceof FormData\n  }\n}\n","import { Func } from '../interface/Func'\nimport { Nullable } from '../interface/Nullable'\nimport { PromiseDeconstruct } from '../interface/PromiseDeconstruct'\n\n/**\n * 安全执行某个函数\n * 支持异步函数\n * @param fn 需要执行的函数\n * @param defaultVal 发生异常后的默认返回值，默认为 null\n * @param args 可选的函数参数\n * @returns 函数执行的结果，或者其默认值\n */\nexport function safeExec<Fn extends Func>(\n  fn: Fn,\n  defaultVal?: ReturnType<Fn>,\n  ...args: Parameters<Fn>\n): Nullable<PromiseDeconstruct<ReturnType<Fn>>> {\n  const defRes = (defaultVal === undefined ? null : defaultVal) as any\n  try {\n    const res = fn(...(args as any))\n    return res instanceof Promise ? res.catch(() => defRes) : res\n  } catch (err) {\n    return defRes\n  }\n}\n","import { returnItself } from './returnItself'\nimport { TypeValidator } from '../obj/TypeValidator'\nimport { safeExec } from './safeExec'\n\n/**\n * 提取对象中的字段并封装为函数\n * @param k 提取的字段，深度获取使用 . 分割不同的字段\n * @returns 获取对象中指定字段的函数\n */\nexport function extractField<T extends object>(\n  k: PropertyKey,\n): (obj: T) => any {\n  const fields: PropertyKey[] = TypeValidator.isString(k) ? k.split('.') : [k]\n  return fields.reduceRight((fn: (obj: T) => any, field: PropertyKey) => {\n    return function (obj: T) {\n      return safeExec(() => fn(Reflect.get(obj as any, field)))\n    }\n  }, returnItself)\n}\n","import { extractField } from '../function/extractField'\nimport { ArrayKFn } from '../interface/ArrayKFn'\nimport { ArrayCallback } from '../interface/ArrayCallback'\n\n/**\n * 获取提取对象属性的函数\n * @param k 提取对象属性的函数或者是属性名（允许使用 . 进行分割）\n * @returns 提取对象属性的函数\n */\nexport function getKFn<T, R>(k: ArrayKFn<T, R>): ArrayCallback<T, R> {\n  return k instanceof Function ? k : (extractField(k) as any)\n}\n","import { ArrayKFn } from '../interface/ArrayKFn'\nimport { getKFn } from './getKFn'\n\n/**\n * 自行实现 flatMap，将数组压平一层\n * @param arr 数组\n * @param k 映射方法，将一个元素映射为一个数组\n * @returns 压平一层的数组\n */\nexport function flatMap<T, V>(\n  arr: T[],\n  k: ArrayKFn<T, V[]> = (v: T) => Array.from(v as any),\n): V[] {\n  const fn = getKFn(k)\n  return arr.reduce((res, v, i, arr) => {\n    res.push(...fn(v, i, arr))\n    return res\n  }, new Array<V>())\n}\n","import { ArrayKFn } from '../interface/ArrayKFn'\nimport { ArrayReduceCallback } from '../interface/ArrayReduceCallback'\nimport { Supplier } from '../interface/Supplier'\nimport { getKFn } from './getKFn'\n\n/**\n * js 数组按照某个条件进行分组\n *\n * @param arr 要进行分组的数组\n * @param k 元素分组的唯一标识函数\n * @returns 元素标识 => 数组映射 Map\n * @typeparam T 数组元素的类型\n * @typeparam K 分组依据的 Key 的类型，也是结果 Map 的 K\n */\nexport function groupBy<T, K>(arr: T[], k: ArrayKFn<T, K>): Map<K, T[]>\n/**\n * js 数组按照某个条件进行分组\n *\n * @param arr 要进行分组的数组\n * @param k 元素分组的唯一标识函数\n * @param vFn 元素分组的值处理的函数。第一个参数是累计值，第二个参数是当前正在迭代的元素，如果你使用过 {@see Array.reduce} 函数的话应该对此很熟悉\n * @returns 元素标识 => 数组映射 Map\n * @typeparam T 数组元素的类型\n * @typeparam K 分组依据的 Key 的类型，也是结果 Map 的 K\n * @typeparam R 如果未指定 init 参数，则 Map 的值必然是一个数组，至于数组的类型则是任意的，由函数参数 vFn 决定\n */\nexport function groupBy<T, K, R>(\n  arr: T[],\n  k: ArrayKFn<T, K>,\n  vFn: ArrayReduceCallback<T, R[]>,\n): Map<K, R[]>\n/**\n * js 数组按照某个条件进行分组\n *\n * @param arr 要进行分组的数组\n * @param k 元素分组的唯一标识函数\n * @param vFn 元素分组的值处理的函数。第一个参数是累计值，第二个参数是当前正在迭代的元素，如果你使用过 {@link Array#reduce} 函数的话应该对此很熟悉\n * @param init 每个分组的产生初始值的函数。类似于 reduce 的初始值，但它是一个函数，避免初始值在所有分组中进行累加。\n * @returns 元素标识 => 数组映射 Map\n * @typeparam T 数组元素的类型\n * @typeparam K 分组依据的 Key 的类型，也是结果 Map 的 K\n * @typeparam V 如果指定了 init 参数，则 Map 的值类型即为 init 函数参数的返回值类型，例如可以使用 init 返回一个 Map 以实现多级级联 Map\n */\nexport function groupBy<T = any, K = any, V = []>(\n  arr: T[],\n  k: ArrayKFn<T, K>,\n  vFn: ArrayReduceCallback<T, V>,\n  init: Supplier<V>,\n): Map<K, V>\nexport function groupBy<T, K, V = T[]>(\n  arr: T[],\n  k: ArrayKFn<T, K>,\n  /**\n   * 默认的值处理函数\n   * @param res 最终 V 集合\n   * @param item 当前迭代的元素\n   * @returns 将当前元素合并后的最终 V 集合\n   */\n  vFn: ArrayReduceCallback<T, V> = ((res: T[], item: T) => {\n    res.push(item)\n    return res\n  }) as any,\n  init: Supplier<V> = () => [] as any,\n): Map<K, V> {\n  const kFn = getKFn(k)\n  // 将元素按照分组条件进行分组得到一个 条件 -> 数组 的对象\n  return arr.reduce((res, item: T, index: number, arr: T[]) => {\n    const k = kFn(item, index, arr)\n    // 如果已经有这个键了就直接追加, 否则先将之初始化再追加元素\n    if (!res.has(k)) {\n      res.set(k, init())\n    }\n    res.set(k, vFn(res.get(k)!, item, index, arr))\n    return res\n  }, new Map<K, V>())\n}\n","/**\n * 创建一个等差数列数组\n * @param start 开始（包含）\n * @param end 结束（不包含）\n * @param sep 步长，默认为 1\n * @returns 等差数列数组\n */\nexport function range(start: number, end: number, sep = 1): number[] {\n  const arr = []\n  for (let i = start; i < end; i += sep) {\n    arr.push(i)\n  }\n  return arr\n}\n","import { ArrayKFn } from '../interface/ArrayKFn'\nimport { returnItself } from '../function/returnItself'\nimport { getKFn } from './getKFn'\n\nexport function toObject<T, K extends PropertyKey>(\n  arr: T[],\n  kFn: ArrayKFn<T, K>,\n): Record<K, T>\nexport function toObject<T, K extends PropertyKey, V>(\n  arr: T[],\n  kFn: ArrayKFn<T, K>,\n  vFn: ArrayKFn<T, V>,\n): Record<K, V>\n/**\n * 将数组转化为一个 Object 对象\n * @deprecated 已废弃，请使用更好的 {@link arrayToMap} 替代\n * @param arr 需要进行转换的数组\n * @param k 生成对象属性名的函数\n * @param v 生成对象属性值的函数，默认为数组中的迭代元素\n * @returns 转化得到的对象\n */\nexport function toObject<T, K extends PropertyKey, V>(\n  arr: T[],\n  k: ArrayKFn<T, K>,\n  v: ArrayKFn<T, V> = returnItself,\n): Record<PropertyKey, V> {\n  const kFn = getKFn(k)\n  const vFn = getKFn(v)\n  return arr.reduce((res: Record<PropertyKey, V>, item, i, arr) => {\n    const k = kFn(item, i, arr)\n    if (!Reflect.has(res, k)) {\n      Reflect.set(res, k, vFn(item, i, arr))\n    }\n    return res\n  }, {})\n}\n","import { returnItself } from '../function/returnItself'\nimport { ArrayKFn } from '../interface/ArrayKFn'\nimport { getKFn } from './getKFn'\n\n/**\n * js 的数组去重方法\n * @param arr 要进行去重的数组\n * @param k 唯一标识元素的方法，默认使用 {@link returnItself}\n * @returns 进行去重操作之后得到的新的数组 (原数组并未改变)\n */\nexport function uniqueBy<T, K>(\n  arr: T[],\n  k: ArrayKFn<T, K> = returnItself,\n): T[] {\n  const kFn = getKFn(k)\n  const set = new Set()\n  return arr.filter((v, ...args) => {\n    const k = kFn(v, ...args)\n    if (set.has(k)) {\n      return false\n    }\n    set.add(k)\n    return true\n  })\n}\n","import { returnItself } from '../function/returnItself'\nimport { ArrayKFn } from '../interface/ArrayKFn'\nimport { getKFn } from './getKFn'\nimport { ArrayDeconstruct } from '../interface/ArrayDeconstruct'\n\nexport function arrayToMap<T extends any[], K, V>(\n  arr: T,\n  k: ArrayKFn<ArrayDeconstruct<T>, K>,\n): Map<K, ArrayDeconstruct<T>>\nexport function arrayToMap<T extends any[], K, V>(\n  arr: T,\n  k: ArrayKFn<ArrayDeconstruct<T>, K>,\n  v?: ArrayKFn<ArrayDeconstruct<T>, V>,\n): Map<K, V>\n/**\n * 将数组映射为 Map\n * @param arr 数组\n * @param k 产生 Map 元素唯一标识的函数，或者对象元素中的一个属性名\n * @param v 产生 Map 值的函数，默认为返回数组的元素，或者对象元素中的一个属性名\n * @returns 映射产生的 map 集合\n */\nexport function arrayToMap<T extends any[], K, V>(\n  arr: T,\n  k: ArrayKFn<ArrayDeconstruct<T>, K>,\n  v: ArrayKFn<ArrayDeconstruct<T>, V> = returnItself,\n): Map<K, V> {\n  const kFn = getKFn(k)\n  const vFn = getKFn(v)\n  return arr.reduce(\n    (res, item, index, arr) =>\n      res.set(kFn(item, index, arr), vFn(item, index, arr)),\n    new Map<K, V>(),\n  )\n}\n","import { arrayToMap } from './../array/arrayToMap'\nimport { Nullable } from '../interface/Nullable'\nimport { isRange } from '../number/isRange'\n\n/**\n * 日期格式化类\n */\nclass DateFormat {\n  /**\n   * 构造函数\n   * @param name 日期格式的名称\n   * @param format 日期的格式值\n   * @param value 格式化得到的值\n   * @param index 需要替换位置的索引\n   */\n  constructor(\n    public name: string,\n    public format: string,\n    public value: string,\n    public index: number,\n  ) {}\n}\n\n/**\n * 日期时间的正则表达式\n */\nconst dateFormats = new Map()\n  .set('year', 'Y{4}|Y{2}|y{4}|y{2}')\n  .set('month', 'M{1,2}')\n  .set('day', 'D{1,2}|d{1,2}')\n  .set('hour', 'h{1,2}')\n  .set('minute', 'm{1,2}')\n  .set('second', 's{1,2}')\n  .set('millieSecond', 'S{1,3}')\n/**\n * 如果没有格式化某项的话则设置为默认时间\n */\nconst defaultDateValues = new Map()\n  .set('month', '01')\n  .set('day', '01')\n  .set('hour', '00')\n  .set('minute', '00')\n  .set('second', '00')\n  .set('millieSecond', '000')\n\n/**\n * 月份日期校验\n */\nconst monthDayValidate = {\n  1: 31,\n  3: 31,\n  5: 31,\n  7: 31,\n  8: 31,\n  10: 31,\n  12: 31,\n  4: 30,\n  6: 30,\n  9: 30,\n  11: 30,\n  2: 28,\n}\n/**\n * 解析字符串为 Date 对象\n * @param str 日期字符串\n * @param fmt 日期字符串的格式，目前仅支持使用 y(年),M(月),d(日),h(时),m(分),s(秒),S(毫秒)\n * @returns 解析得到的 Date 对象\n */\nexport function dateParse(str: string, fmt: string): Nullable<Date> {\n  const now = new Date()\n  defaultDateValues.set('year', now.getFullYear().toString())\n  // 保存对传入的日期字符串进行格式化的全部信息数组列表\n  const dateUnits: DateFormat[] = []\n  for (const [fmtName, regex] of dateFormats) {\n    const regExp = new RegExp(regex)\n    if (regExp.test(fmt)) {\n      const matchStr = regExp.exec(fmt)![0]\n      const regexStr = '`'.repeat(matchStr.length)\n      const index = fmt.indexOf(matchStr)\n      fmt = fmt.replace(matchStr, regexStr)\n      dateUnits.push(\n        new DateFormat(fmtName, '\\\\d'.repeat(matchStr.length), null!, index),\n      )\n    } else {\n      dateUnits.push(\n        new DateFormat(fmtName, null!, defaultDateValues.get(fmtName), -1),\n      )\n    }\n  }\n  // 进行验证是否真的是符合传入格式的字符串\n  fmt = fmt.replace(new RegExp('`', 'g'), '\\\\d')\n  if (!new RegExp(`^${fmt}$`).test(str)) {\n    return null\n  }\n  // 进行一次排序, 依次对字符串进行截取\n  dateUnits\n    // 过滤掉没有得到格式化的对象\n    .filter(({ format }) => format)\n    // 按照字符串中日期片段的索引进行排序\n    .sort(function (a, b) {\n      return a.index - b.index\n    })\n    // 获取到匹配的日期片段的值\n    .map((format) => {\n      const matchDateUnit = new RegExp(format.format).exec(str)\n      if (matchDateUnit !== null && matchDateUnit.length > 0) {\n        str = str.replace(matchDateUnit[0], '')\n        format.value = matchDateUnit[0]\n      }\n      return format\n    })\n    // 覆写到 dateStr 上面\n    .forEach(({ format }, i) => {\n      const matchDateUnit = new RegExp(format).exec(str)\n      if (matchDateUnit !== null && matchDateUnit.length > 0) {\n        str = str.replace(matchDateUnit[0], '')\n        dateUnits[i].value = matchDateUnit[0]\n      }\n    })\n  // 将截取完成的信息封装成对象并格式化标准的日期字符串\n  const map = arrayToMap(\n    dateUnits,\n    (item) => item.name,\n    (item) => item.value,\n  )\n  if (map.get('year')!.length === 2) {\n    map.set(\n      'year',\n      defaultDateValues.get('year').substr(0, 2).concat(map.get('year')),\n    )\n  }\n  // 注意：此处使用的是本地时间而非 UTC 时间\n  const get = (unit: string) => parseInt(map.get(unit)!)\n  const year = get('year')\n  const month = get('month')\n  const day = get('day')\n  const hour = get('hour')\n  const minute = get('minute')\n  const second = get('second')\n  const millieSecond = get('millieSecond')\n  if (!isRange(month, 1, 12 + 1)) {\n    return null\n  }\n  if (\n    !isRange(\n      day,\n      1,\n      Reflect.get(monthDayValidate, month) +\n        (month === 2 && year % 4 === 0 ? 1 : 0) +\n        1,\n    )\n  ) {\n    return null\n  }\n  if (\n    !isRange(hour, 0, 24 + 1) ||\n    !isRange(minute, 0, 60 + 1) ||\n    !isRange(second, 0, 60 + 1) ||\n    !isRange(millieSecond, 0, 999 + 1)\n  ) {\n    return null\n  }\n  return new Date(year, month - 1, day, hour, minute, second, millieSecond)\n}\n","import { dateParse } from './dateParse'\n\n/**\n * 解析字符串为 Date 对象\n * @deprecated 已弃用，请使用可读性更好的 {@link dateParse} 代替\n * @param dateStr 日期字符串\n * @param fmt 日期字符串的格式\n * 目前仅支持使用 y(年),M(月),d(日),h(时),m(分),s(秒),S(毫秒)\n * @returns 解析得到的 Date 对象\n */\nexport function strToDate(dateStr: string, fmt: string): Date | null {\n  return dateParse(dateStr, fmt)\n}\n","/**\n * 复制一段文本内容\n * @param text 要进行复制的文本\n * @returns 是否复制成功\n */\nexport function copyText(text: string): boolean {\n  const $el = document.createElement('textarea')\n  $el.style.position = 'fixed'\n  $el.style.top = '-1000px'\n  document.body.appendChild($el)\n  $el.value = text\n  $el.select()\n  const res = document.execCommand('copy')\n  document.body.removeChild($el)\n  return res\n}\n","import { Nullable } from '../interface/Nullable'\n\n/**\n * 根据 html 字符串创建 Element 元素\n * @param str html 字符串\n * @returns 创建的 Element 元素\n */\nexport function createElByString(str: string): Nullable<Element> {\n  const root = document.createElement('div')\n  root.innerHTML = str\n  return root.querySelector('*')\n}\n","/**\n * 获取输入框中光标所在位置\n * @param  {HTMLFormElement} el 需要获取的输入框元素\n * @returns 光标所在位置的下标\n */\nexport function getCursorPosition(el: HTMLFormElement): number {\n  return el.selectionStart\n}\n","import { getCursorPosition } from './getCursorPosition'\n\n/**\n * 获取输入框中光标所在位置\n * @param  {HTMLFormElement} el 需要获取的输入框元素\n * @returns 光标所在位置的下标\n * @deprecated 已废弃，请使用正确更名后的 {@link getCursorPosition} 函数\n */\nexport function getCusorPostion(el: HTMLFormElement): number {\n  return getCursorPosition(el)\n}\n","/**\n * 设置输入框中选中的文本/光标所在位置\n * @param el 需要设置的输入框元素\n * @param start 光标所在位置的下标\n * @param end 结束位置，默认为输入框结束\n */\nexport function setCursorPosition(\n  el: HTMLFormElement,\n  start: number,\n  end: number = start,\n) {\n  el.focus()\n  el.setSelectionRange(start, end)\n}\n","import { getCursorPosition } from './getCursorPosition'\nimport { setCursorPosition } from './setCursorPosition'\n\n/**\n * 在指定位置后插入文本\n * @param el 需要设置的输入框元素\n * @param text 要插入的值\n * @param start 开始位置，默认为当前光标处\n */\nexport function insertText(\n  el: HTMLFormElement,\n  text: string,\n  start: number = getCursorPosition(el),\n) {\n  const value = el.value\n  el.value = value.substr(0, start) + text + value.substr(start)\n  setCursorPosition(el, start + text.length)\n}\n","import { isNullOrUndefined } from '../obj/isNullOrUndefined'\n\n/**\n * 字符串安全的转换为小写\n * @param str 字符串\n * @returns 转换后得到的全小写字符串\n */\nexport function toLowerCase<T = string | undefined | null>(str: T): T {\n  if (isNullOrUndefined(str) || typeof str !== 'string') {\n    return str\n  }\n  return str.toLowerCase() as any\n}\n","import { toLowerCase } from '../string/toLowerCase'\n\n/**\n * 判断指定元素是否是可编辑元素\n * 注：可编辑元素并不一定能够进行编辑，例如只读的 input 元素\n * @param el 需要进行判断的元素\n * @returns 是否为可编辑元素\n */\nexport function isEditable(el: Element): boolean {\n  const inputEls = ['input', 'date', 'datetime', 'select', 'textarea']\n  return (\n    // 此处需要判断是否存在属性 isContentEditable\n    // @ts-ignore\n    el && (el.isContentEditable || inputEls.includes(toLowerCase(el.tagName)))\n  )\n}\n","import { Nullable } from '../interface/Nullable'\n\nlet lastFocusEl: Nullable<Element> | EventTarget\n\n/**\n * 获取到最后一个获得焦点的元素\n * @returns 最后一个获取到焦点的元素\n */\nfunction _lastFocus(): Nullable<Element> | EventTarget {\n  return lastFocusEl\n}\n\nexport const lastFocus = Object.assign(_lastFocus, {\n  init() {\n    document.addEventListener(\n      'focus',\n      (event) => {\n        lastFocusEl = event.target\n      },\n      true,\n    )\n    document.addEventListener(\n      'blur',\n      () => {\n        lastFocusEl = null\n      },\n      true,\n    )\n  },\n})\n","import { Nullable } from '../interface/Nullable'\n\n/**\n * 直接删除指定元素\n * @param el 需要删除的元素\n * @returns 返回被删除的元素\n */\nexport function removeEl(el: Element): Nullable<Node> {\n  const parent = el.parentElement\n  if (parent == null) {\n    return null\n  }\n  return parent.removeChild(el)\n}\n","import { getCursorPosition } from './getCursorPosition'\nimport { setCursorPosition } from './setCursorPosition'\n\n/**\n * 在指定范围内删除文本\n * @param el 需要设置的输入框元素\n * @param start 开始位置，默认为当前选中开始位置\n * @param end 结束位置，默认为当前选中结束位置\n */\nexport function removeText(\n  el: HTMLFormElement,\n  start: number = el.selectionStart,\n  end: number = el.selectionEnd,\n) {\n  // 删除之前必须要 [记住] 当前光标的位置\n  const index = getCursorPosition(el)\n  const value = el.value\n  el.value = value.substr(0, start) + value.substr(end, value.length)\n  setCursorPosition(el, index)\n}\n","import { setCursorPosition } from './setCursorPosition'\n\n/**\n * 设置输入框中选中的文本/光标所在位置\n * @param el 需要设置的输入框元素\n * @param start 光标所在位置的下标\n * @param end 结束位置，默认为输入框结束\n * @deprecated 已废弃，请使用正确更名后的 {@link setCursorPosition} 函数\n */\nexport function setCusorPostion(\n  el: HTMLFormElement,\n  start: number,\n  end: number = start,\n) {\n  return setCursorPosition(el, start, end)\n}\n","/**\n * 监听 event 的添加/删除，使 DOM 事件是可撤销的\n * 注：必须及早运行，否则无法监听之前添加的事件\n * @deprecated 实际上 {@link EventUtil} 已经更好的实现了这个功能，如果需要则直接修改原型即可，无需使用该函数\n */\nexport function watchEventListener() {\n  /**\n   * 用来保存监听到的事件信息\n   */\n  class Event {\n    constructor(\n      public el: Element,\n      public type: string,\n      public listener: EventListener,\n      public useCapture: boolean,\n    ) {}\n  }\n  /**\n   * 监听所有的 addEventListener, removeEventListener 事件\n   */\n  const documentAddEventListener = document.addEventListener\n  const eventTargetAddEventListener = EventTarget.prototype.addEventListener\n  const documentRemoveEventListener = document.removeEventListener\n  const eventTargetRemoveEventListener =\n    EventTarget.prototype.removeEventListener\n  const events: Event[] = []\n\n  /**\n   * 自定义的添加事件监听函数\n   * @param type 事件类型\n   * @param listener 事件监听函数\n   * @param [useCapture] 是否需要捕获事件冒泡，默认为 false\n   */\n  function addEventListener(\n    type: string,\n    listener: EventListener,\n    useCapture = false,\n  ) {\n    const $addEventListener =\n      // @ts-ignore\n      this === document ? documentAddEventListener : eventTargetAddEventListener\n    // @ts-ignore\n    events.push(new Event(this, type, listener, useCapture))\n    // @ts-ignore\n    $addEventListener.apply(this, arguments)\n  }\n\n  /**\n   * 自定义的根据类型删除事件函数\n   * 该方法会删除这个类型下面全部的监听函数，不管数量\n   * @param type 事件类型\n   */\n  function removeEventListenerByType(type: string) {\n    const $removeEventListener =\n      // @ts-ignore\n      this === document\n        ? documentRemoveEventListener\n        : eventTargetRemoveEventListener\n    const removeIndexList = events\n      // @ts-ignore\n      .map((e, i) => (e.el === this || e.type === arguments[0] ? i : -1))\n      .filter((i) => i !== -1)\n    removeIndexList.forEach((i) => {\n      const e = events[i]\n      $removeEventListener.apply(e.el, [e.type, e.listener, e.useCapture])\n    })\n    removeIndexList.sort((a, b) => b - a).forEach((i) => events.splice(i, 1))\n  }\n\n  document.addEventListener = EventTarget.prototype.addEventListener = addEventListener\n  // @ts-ignore\n  document.removeEventListenerByType = EventTarget.prototype.removeEventListenerByType = removeEventListenerByType\n}\n","import { isNullOrUndefined } from '../obj/isNullOrUndefined'\n\n/**\n * 将任意对象转换为 String\n * 主要避免原生 Object toString 遇到某些空值的时候抛异常的问题\n * @param object 任意对象\n * @returns 字符串\n */\nexport function toString(object: any): string {\n  if (isNullOrUndefined(object)) {\n    return ''\n  }\n  if (object instanceof Date) {\n    return object.toISOString()\n  }\n  return object.toString()\n}\n","import { toString } from '../string/toString'\n\n/**\n * FormData 批量添加方法\n * 注：该方法不会覆盖掉原本的属性\n * @param fd FormData 对象\n * @param obj 键值对对象\n * @returns 添加完成后的 FormData 对象\n */\nexport function appends(\n  fd: FormData,\n  obj: Record<string, string | Blob | any>,\n): FormData {\n  for (const k in obj) {\n    const v = obj[k]\n    fd.append(k, toString(v))\n  }\n  return fd\n}\n","/**\n * FormData 批量删除方法\n * @param fd FormData 对象\n * @param keys  删除的 key 列表\n * @returns 返回删除后的 FormData 对象\n */\nexport function deletes(fd: FormData, keys: string[]): FormData {\n  keys.forEach((key) => fd.delete(key))\n  return fd\n}\n","/**\n * FormData 批量设置方法\n * 注：该方法会覆盖掉原本的属性\n * @param fd 表单对象\n * @param obj 键值对对象\n * @returns 设置完成后的 FormData 对象\n */\nexport function sets(\n  fd: FormData,\n  obj: Record<string, string | Blob | any>,\n): FormData {\n  for (const k in obj) {\n    fd.set(k, obj[k])\n  }\n  return fd\n}\n","/**\n * FormData 转换为包含所有键值数组的二维数组函数\n *\n * @param fd 需要转换的 FormData 对象\n * @returns 转换后的数组\n * @deprecated 已被原生函数 Array.from 取代\n */\nexport function formDataToArray(fd: FormData): Array<[string, string | Blob]> {\n  // @ts-ignore\n  return Array.from(fd)\n}\n","/**\n * 将参数对象转换为 FormData，只转换一层\n * @param data 参数对象\n * @return {FormData} 转换后的表单对象\n */\nexport function objToFormData(\n  data: Record<string, string | Blob | any>,\n): FormData {\n  return Object.entries(data).reduce((res, [k, v]) => {\n    if (v instanceof Blob) {\n      res.append(k, v)\n    } else {\n      res.append(k, v && v.toString())\n    }\n    return res\n  }, new FormData())\n}\n","import { Func } from '../interface/Func'\nimport { Async } from '../interface/Async'\n\n/**\n * 函数去抖\n * 去抖 (debounce) 去抖就是对于一定时间段的连续的函数调用，只让其执行一次\n * 注: 包装后的函数如果两次操作间隔小于 delay 则不会被执行, 如果一直在操作就会一直不执行, 直到操作停止的时间大于 delay 最小间隔时间才会执行一次, 不管任何时间调用都需要停止操作等待最小延迟时间\n * 应用场景主要在那些连续的操作, 例如页面滚动监听, 包装后的函数只会执行最后一次\n * 注: 该函数第一次调用一定不会执行，第一次一定拿不到缓存值，后面的连续调用都会拿到上一次的缓存值。如果需要在第一次调用获取到的缓存值，则需要传入第三个参数 {@param init}，默认为 {@code undefined} 的可选参数\n * 注: 返回函数结果的高阶函数需要使用 {@see Proxy} 实现，以避免原函数原型链上的信息丢失\n *\n * @param delay 最小延迟时间，单位为 ms\n * @param action 真正需要执行的操作\n * @param init 初始的缓存值，不填默认为 {@see undefined}\n * @return 包装后有去抖功能的函数。该函数是异步的，与需要包装的函数 {@see action} 是否异步没有太大关联\n */\nexport function debounce<Fn extends Func>(\n  delay: number,\n  action: Fn,\n  init: any = null,\n): Async<Fn> {\n  let flag: number\n  let result = init\n  return new Proxy(action, {\n    apply(_: Func, _this: any, args: ArrayLike<any>) {\n      return new Promise((resolve) => {\n        if (flag) clearTimeout(flag)\n        flag = setTimeout(\n          () => resolve((result = Reflect.apply(_, _this, args))),\n          delay,\n        )\n        setTimeout(() => resolve(result), delay)\n      })\n    },\n  })\n}\n","import { Newable } from '../interface/Newable'\n\n/**\n * 使用 Proxy 实现通用的单例模式\n * @param clazz 需要包装为单例的类型\n * @returns 包装后的单例模式类，使用 {@code new} 创建将只在第一次有效\n */\nexport function singleModel<\n  R extends object,\n  Clazz extends Function = Newable<R>\n>(clazz: Clazz): Clazz {\n  let instance: R\n  return new Proxy(clazz, {\n    construct(target, args, newTarget) {\n      if (instance === undefined) {\n        instance = Reflect.construct(target, args, newTarget)\n      }\n      return instance\n    },\n  })\n}\n","import { Newable } from '../interface/Newable'\nimport { Nullable } from '../interface/Nullable'\n\n/**\n * 状态机\n * 用于避免使用 if-else 的一种方式\n * @typeparam K 状态的类型，默认为 any\n * @typeparam V 构造函数返回值的类型，一般为实现子类的基类，默认为 any\n * @deprecated 该类将在下个大版本进行重构，使用函数而非类作为基本单元\n */\nexport class StateMachine<K = any, R = any> {\n  /**\n   * 获取到一个状态工厂\n   * @deprecated 已废弃，请直接创建一个 StateMachine 实例\n   */\n  public static getFactory<K>() {\n    /**\n     * 状态注册器\n     * 更好的有限状态机，分离子类与构建的关系，无论子类如何增删该都不影响基类及工厂类\n     */\n    return new StateMachine<K>()\n  }\n  private classMap = new Map<K, Newable<R>>()\n  /**\n   * 注册一个 class，创建子类时调用，用于记录每一个 [状态 => 子类] 对应\n   * 注: 此处不再默认使用单例模式，如果需要，请自行对 class 进行包装\n   * @param state 作为键的状态\n   * @param clazz 对应的子类型\n   * @returns 返回 clazz 本身\n   */\n  public register(state: K, clazz: Newable<R>): Newable<R> {\n    this.classMap.set(state, clazz)\n    return clazz\n  }\n\n  /**\n   * 获取一个标签子类对象\n   * @param state 状态索引\n   * @param args 构造函数的参数\n   * @returns 子类对象\n   */\n  public getInstance(state: K, ...args: any[]): Nullable<R> {\n    const Class = this.classMap.get(state)\n    if (!Class) {\n      return null\n    }\n    // 构造函数的参数\n    return new Class(...args)\n  }\n  /**\n   * 允许使用 for-of 遍历整个状态机\n   */\n  public *[Symbol.iterator]() {\n    for (const kv of this.classMap.entries()) {\n      yield kv\n    }\n  }\n}\n","import { ReturnFunc } from '../interface/ReturnFunc'\nimport { Func } from '../interface/Func'\nimport { Async } from '../interface/Async'\nimport { PromiseDeconstruct } from '../interface/PromiseDeconstruct'\n\n/**\n * 函数节流\n * 节流 (throttle) 让一个函数不要执行的太频繁，减少执行过快的调用，叫节流\n * 类似于上面而又不同于上面的函数去抖, 包装后函数在上一次操作执行过去了最小间隔时间后会直接执行, 否则会忽略该次操作\n * 与上面函数去抖的明显区别在连续操作时会按照最小间隔时间循环执行操作, 而非仅执行最后一次操作\n * 注: 该函数第一次调用一定会执行，不需要担心第一次拿不到缓存值，后面的连续调用都会拿到上一次的缓存值\n * 注: 返回函数结果的高阶函数需要使用 {@see Proxy} 实现，以避免原函数原型链上的信息丢失\n *\n * @param delay 最小间隔时间，单位为 ms\n * @param action 真正需要执行的操作\n * @return {Function} 包装后有节流功能的函数。该函数是异步的，与需要包装的函数 {@link action} 是否异步没有太大关联\n */\nexport function throttle<Fn extends Func>(\n  delay: number,\n  action: Fn,\n): Async<Fn> {\n  let last = 0\n  let result: PromiseDeconstruct<ReturnType<Fn>>\n  return new Proxy(action, {\n    apply(target, thisArg, args) {\n      return new Promise((resolve) => {\n        const curr = Date.now()\n        if (curr - last > delay) {\n          result = Reflect.apply(target, thisArg, args)\n          last = curr\n          resolve(result)\n          return\n        }\n        resolve(result)\n      })\n    },\n  })\n}\n","import { ReturnFunc } from '../interface/ReturnFunc'\nimport { compatibleAsync } from '../async/compatibleAsync'\n\n/**\n * 测试函数的执行时间\n * 注：如果函数返回 Promise，则该函数也会返回 Promise，否则直接返回执行时间\n * @param fn 需要测试的函数\n * @returns 执行的毫秒数\n */\nexport function timing<R>(\n  fn: ReturnFunc<R>,\n  // 函数返回类型是 Promise 的话，则返回 Promise<number>，否则返回 number\n): R extends Promise<any> ? Promise<number> : number {\n  const begin = performance.now()\n  const res = fn()\n  return compatibleAsync(res, () => performance.now() - begin)\n}\n","import { ReturnFunc } from '../interface/ReturnFunc'\n\n/**\n * 等待指定资源加载的可选参数接口\n */\ninterface IWaitResourceOptions {\n  /**\n   * 轮询间隔\n   */\n  interval: number\n  /**\n   * 最大轮询次数\n   */\n  max: number\n}\n/**\n * 轮询等待指定资源加载完毕再执行操作\n * 使用 Promises 实现，可以使用 ES7 的 {@see async} 和 {@see await} 调用\n * @param fn 判断必须的资源是否存在的方法\n * @param option 可配置项\n * @returns Promise 对象\n */\nexport function waitResource(\n  fn: ReturnFunc<boolean>,\n  { interval = 100, max = 10 }: Partial<IWaitResourceOptions> = {},\n) {\n  let current = 0\n  return new Promise((resolve, reject) => {\n    const timer = setInterval(() => {\n      if (fn()) {\n        clearInterval(timer)\n        resolve()\n      }\n      current++\n      if (current >= max) {\n        clearInterval(timer)\n        reject(new Error('waitResource call timeout'))\n      }\n    }, interval)\n  })\n}\n","import { ReturnFunc } from '../interface/ReturnFunc'\n\n/**\n * 监视指定函数返回值的变化\n * @param fn 需要监视的函数\n * @param callback 回调函数\n * @param interval 每次检查的间隔时间，默认为 100ms\n * @returns 关闭这个监视函数\n */\nexport function watch<R>(\n  fn: ReturnFunc<R>,\n  callback: (newVal: R, oldVal: R) => void,\n  interval = 100,\n): Function {\n  let oldVal = fn()\n  const timer = setInterval(() => {\n    const newVal = fn()\n    if (oldVal !== newVal) {\n      callback(newVal, oldVal)\n      oldVal = newVal\n    }\n  }, interval)\n  return () => clearInterval(timer)\n}\n","/**\n * 深度监听指定对象属性的变化\n * 注：指定对象不能是原始类型，即不可变类型，而且对象本身的引用不能改变，最好使用 const 进行声明\n * @param object 需要监视的对象\n * @param callback 当代理对象发生改变时的回调函数，回调函数有三个参数，分别是对象，修改的 key，修改的 v\n * @returns 返回源对象的一个代理\n */\nexport function watchObject<T extends object>(\n  object: T,\n  callback: (target: T, k: PropertyKey, v: any) => void,\n): object {\n  const handler: ProxyHandler<T> = {\n    get(target, k) {\n      try {\n        // 注意: 这里很关键，它为对象的字段也添加了代理\n        return new Proxy(Reflect.get(target, k), handler)\n      } catch (err) {\n        return Reflect.get(target, k)\n      }\n    },\n    set(target, k, v) {\n      callback(target, k, v)\n      return Reflect.set(target, k, v)\n    },\n  }\n  return new Proxy(object, handler)\n}\n","/**\n * 填充字符串到指定长度\n * @param item 填充的字符串\n * @param len 填充的长度\n * @returns 填充完成的字符串\n * @deprecated 已废弃，请使用 ES6 {@link String.prototype.repeat} 函数\n * 具体请参考 MDN {@url(https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/repeat)}\n */\nexport function fill(item: string, len: number): string {\n  if (len <= 0) {\n    return ''\n  }\n  return item + fill(item, len - 1)\n}\n","import { toString } from '../string/toString'\n\n/**\n * 字符串格式化\n *\n * @param str 要进行格式化的值\n * @param args 格式化参数值，替换字符串中的 {} 的值\n * @returns 替换完成的字符串\n * @deprecated 已废弃，请使用 ES6 模板字符串 {@url(https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/template_strings)}\n */\nexport function format(str: string, args: Record<string, any>): string {\n  return Object.keys(args).reduce(\n    (res, k) => res.replace(new RegExp(`{${k}}`, 'g'), toString(args[k])),\n    str,\n  )\n}\n","import { stringValidator } from './StringValidator'\n\n/**\n * 判断字符串是否位小数\n * @param str 需要进行判断的字符串\n * @returns 是否为小数\n * @deprecated 已废弃，请使用 {@link stringValidator#isFloat}\n */\nexport function isFloat(str: string | null | undefined): boolean {\n  return stringValidator.isFloat(str)\n}\n","import { stringValidator } from './StringValidator'\n\n/**\n * 判断字符串是否位整数\n * @param str 需要进行判断的字符串\n * @returns 是否为小数\n * @deprecated 已废弃，请使用 {@link stringValidator#isInteger}\n */\nexport function isNumber(str: string): boolean {\n  return stringValidator.isInteger(str)\n}\n","import { isNullOrUndefined } from '../obj/isNullOrUndefined'\n\n/**\n * 字符串安全的转换为大写\n * @param str 字符串\n * @returns 转换后得到的全大写字符串\n */\nexport function toUpperCase<T = string | undefined | null>(str: T): T {\n  if (isNullOrUndefined(str) || typeof str !== 'string') {\n    return str\n  }\n  return str.toUpperCase() as any\n}\n","import { StringValidator } from './StringValidator'\n\n/**\n * 将空白字符串转换为 null\n *\n * @param str 将空字符串转换为 {@code null}\n * @returns 可能为 {@code null}\n */\nexport function blankToNull(str: string): string | null {\n  return StringValidator.isBlank(str) ? null : str\n}\n","import { blankToNull } from './../string/blankToNull'\n\n/**\n * 置空对象所有空白的属性\n * @param obj 对象\n * @returns 将所有的空白属性全部转换为 null 的新对象\n */\nexport function blankToNullField<T extends object>(obj: T): T {\n  return Object.keys(obj).reduce((res, k) => {\n    const v = Reflect.get(obj, k)\n    Reflect.set(res, k, typeof v === 'string' ? blankToNull(v) : v)\n    return res\n  }, {}) as any\n}\n","/**\n * 将对象的所有属性置空\n * @param obj 需要置空属性的对象\n * @returns 返回一个新的对象\n */\nexport function emptyAllField<T extends object>(obj: T): T {\n  return Object.keys(obj).reduce((res, k) => {\n    Reflect.set(res, k, null)\n    return res\n  }, {}) as any\n}\n","/**\n * 排除对象中的指定字段\n * 注: 此处将获得一个浅拷贝对象\n * @param obj 排除对象\n * @param fields 要排除的多个字段\n * @returns 排除完指定字段得到的新的对象\n */\nexport function excludeFields<T extends object, K extends keyof T>(\n  obj: T,\n  ...fields: K[]\n): Omit<T, K> {\n  const set = new Set(fields)\n  return Object.keys(obj).reduce((res, k) => {\n    if (!set.has(k as any)) {\n      Reflect.set(res, k, Reflect.get(obj, k))\n    }\n    return res\n  }, {}) as any\n}\n","/**\n * 将 Map 转换为 Object 对象\n * @param map Map 键值表\n * @returns 转换得到的 Object 对象\n */\nexport function mapToObject(map: Map<PropertyKey, any>): object {\n  const res = {}\n  for (const [k, v] of map) {\n    Reflect.set(res, k, v)\n  }\n  return res\n}\n","/**\n * 生成一个随机的数字\n * @param max 最大值，最小值默认为 0\n * @returns 生成的随机整数\n * @throws 当 max 小于等于 0 时\n */\nexport function randomInt(max: number): number\n/**\n * 生成一个随机的数字\n * @param min 最小值\n * @param max 最大值（不包含）\n * @returns 生成的随机整数\n * @throws 当 max 小于等于 0 时\n */\nexport function randomInt(min: number, max: number): number\nexport function randomInt(num1: number, num2?: number): number {\n  const min = num2 ? num1 : 0\n  const max = num2 ? num2 : num1\n  if (max <= 0) {\n    throw new Error('最大值不能为 0')\n  }\n  return min + Math.floor(Math.random() * (max - min))\n}\n","import { dateFormat } from './dateFormat'\n\n/**\n * 计算月有多少天\n * @param date 日期\n * @returns 月的总天数\n */\nfunction calcMonEndDay(date: Date) {\n  const monthToDay: Array<[Set<number>, number]> = [\n    [new Set([1, 3, 5, 7, 8, 10, 12]), 30],\n    [new Set([4, 6, 9, 11]), 30],\n    [new Set([2]), 28],\n  ]\n  const year = date.getFullYear()\n  const month = date.getMonth() + 1\n  const days = monthToDay.find(([monthSet]) => monthSet.has(month))![1]\n  return days + (month === 2 && year % 4 === 0 ? 1 : 0)\n}\n\n/**\n * 日期固定时间点\n */\nexport class DateConstants {\n  /**\n   * 获取指定日期一天的开始时间\n   * @param date 指定的时间，默认为当前日期\n   * @returns 一天的开始时间\n   */\n  public static dayStart(date: Date = new Date()): Date {\n    return new Date(`${dateFormat(date, 'yyyy-MM-dd')}T00:00:00.000`)\n  }\n  /**\n   * 获取指定日期一天的结束时间\n   * @param date 指定的时间，默认为当前日期\n   * @returns 一天的结束时间\n   */\n  public static dayEnd(date: Date = new Date()): Date {\n    return new Date(`${dateFormat(date, 'yyyy-MM-dd')}T23:59:59.999`)\n  }\n  /**\n   * 获取指定日期所在月的开始时间\n   * @param date 指定的时间，默认为当前日期\n   * @returns 月的开始时间\n   */\n  public static monthStart(date: Date = new Date()): Date {\n    return new Date(`${dateFormat(date, 'yyyy-MM')}-01T00:00:00.000`)\n  }\n  /**\n   * 获取指定日期所在月的结束时间\n   * @param date 指定的时间，默认为当前日期\n   * @returns 月的结束时间\n   */\n  public static monthEnd(date: Date = new Date()): Date {\n    return new Date(\n      `${dateFormat(date, 'yyyy-MM')}-${calcMonEndDay(date)}T23:59:59.999`,\n    )\n  }\n  /**\n   * 获取指定日期所在年份的新年开始时间\n   * @param date 指定的时间，默认为当前日期\n   * @returns 新年开始时间\n   */\n  public static yearStart(date: Date = new Date()): Date {\n    return new Date(`${date.getFullYear()}-01-01T00:00:00.000`)\n  }\n  /**\n   * 获取指定日期所在年份的旧年结束时间\n   * @param date 指定的时间，默认为当前日期\n   * @returns 旧年结束时间\n   */\n  public static yearEnd(date: Date = new Date()): Date {\n    return new Date(`${date.getFullYear()}-12-31T23:59:59.999`)\n  }\n}\n\n/**\n * 导出一个日期固定时间点的对象\n * @deprecated 已废弃，请直接使用类的静态函数\n */\nexport const dateConstants = DateConstants\n","import { isRange } from '../number/isRange'\nimport { dateConstants } from './DateConstants'\n\n/**\n * 一天标准的毫秒数\n */\nconst DAY_UNIT_TIME = 1000 * 60 * 60 * 24\n/**\n * 日期增强\n */\nexport class DateEnhance {\n  /**\n   * 构造函数\n   * @param date 要增强的日期\n   */\n  constructor(private date: Date) {}\n  /**\n   * 获取到年份\n   * @returns\n   */\n  public year(): number {\n    return this.date.getFullYear()\n  }\n  /**\n   * 获取月份\n   * @returns\n   * @deprecated 已废弃，请使用 {@link this#monthOfYear} 函数\n   */\n  public month(): number {\n    return this.date.getMonth()\n  }\n  /**\n   * 获取今年的第几个月份\n   * 和 {@link this#month} 不同的是不再从 0 计算月份\n   */\n  public monthOfYear() {\n    return this.date.getMonth() + 1\n  }\n  /**\n   * 获取一年内的第多少天\n   * 注: 这个天数指定的在第几天而非过去了多少天，例如 2018-01-10 的结果会是 10\n   * @returns\n   */\n  public dayOfYear(): number {\n    return Math.ceil(\n      (this.date.getTime() - dateConstants.yearStart(this.date).getTime()) /\n        DAY_UNIT_TIME,\n    )\n  }\n  /**\n   * 获取一个月内的第多少天\n   * 注: 这个天数指的是在第几天而非过去了多少天，例如 2018-01-10 的结果会是 10\n   * @returns\n   */\n  public dayOfMonth(): number {\n    return this.date.getDate()\n  }\n  /**\n   * 获取一个星期内的第多少天\n   * @returns\n   */\n  public dayOfWeek(): number {\n    return this.date.getDay()\n  }\n  /**\n   * 获取一年内的第多少星期\n   * 注: 这个星期指定的在第几天而非过去了多少天，例如 2018-01-10 的结果会是 10\n   * @returns\n   */\n  public weekOfYear(): number {\n    return Math.ceil(this.dayOfYear() / 7)\n  }\n  /**\n   * 获取一个月内的第多少星期\n   * @returns\n   */\n  public weekOfMonth(): number {\n    return Math.ceil(this.dayOfMonth() / 7)\n  }\n  /**\n   * 获取季度\n   * @returns\n   */\n  public quarter(): number {\n    const month = this.month()\n    if (isRange(month, 0, 3)) {\n      return 1\n    } else if (isRange(month, 3, 6)) {\n      return 2\n    } else if (isRange(month, 6, 9)) {\n      return 3\n    } else {\n      return 4\n    }\n  }\n  /**\n   * 获取小时\n   * @returns\n   */\n  public hour(): number {\n    return this.date.getHours()\n  }\n  /**\n   * 获取分钟\n   * @returns\n   */\n  public minute(): number {\n    return this.date.getMinutes()\n  }\n  /**\n   * 获取秒\n   * @returns\n   */\n  public second(): number {\n    return this.date.getSeconds()\n  }\n  /**\n   * 获取毫秒\n   * @returns\n   */\n  public milliSecond(): number {\n    return this.date.getMilliseconds()\n  }\n}\n\n/**\n * 获取一个增强的日期\n * @param date 要增强的日期\n * @returns 增强日期\n */\nexport function dateEnhance(date: Date): DateEnhance {\n  return new DateEnhance(date)\n}\n","import { dateEnhance } from './dateEnhance'\n\n/**\n * 获取一年内的第多少星期\n * @param date 日期\n * @returns 这个日期第多少个星期\n * @deprecated 不推荐使用，请使用 {@see dateEnhance} 代替\n */\nexport function getYearWeek(date: Date): number {\n  return dateEnhance(date).weekOfYear()\n}\n","/**\n * 时间日期间隔\n */\nexport class DateBetween {\n  /**\n   * 构造函数\n   * @param start 开始时间\n   * @param end 结束时间\n   */\n  constructor(private start: Date, private end: Date) {}\n  /**\n   * 获取毫秒差值\n   * @returns 毫秒差值\n   */\n  public milliSecond(): number {\n    return this.end.getTime() - this.start.getTime()\n  }\n  /**\n   * 获取秒差值\n   * @returns 秒差值\n   */\n  public second(): number {\n    return Math.floor(this.milliSecond() / 1000)\n  }\n  /**\n   * 获取分钟差值\n   * @returns 分钟差值\n   */\n  public minute(): number {\n    return Math.floor(this.second() / 60)\n  }\n  /**\n   * 获取小时差值\n   * @returns 小时差值\n   */\n  public hour(): number {\n    return Math.floor(this.minute() / 60)\n  }\n  /**\n   * 获取天数差值\n   * @returns 天数差值\n   */\n  public day(): number {\n    return Math.floor(this.hour() / 24)\n  }\n  /**\n   * 获取月份差值\n   * 注: 此处获取的差值是按月计算的，即 2018-12-31 => 2019-01-01 也被认为相差一个月\n   * @returns 月份差值\n   */\n  public month(): number {\n    const year = this.year()\n    const month = this.end.getMonth() - this.start.getMonth()\n    return year * 12 + month\n  }\n  /**\n   * 获取年份差值\n   * 注: 此处获取的差值是按年计算的，即 2018-12-31 => 2019-01-01 也被认为相差一年\n   * @returns 年份差值\n   */\n  public year(): number {\n    return this.end.getFullYear() - this.start.getFullYear()\n  }\n}\n\n/**\n * 获取两个时间的差值\n * @param start 开始时间\n * @param end 结束时间\n * @returns 差值对象\n */\nexport function dateBetween(start: Date, end: Date): DateBetween {\n  return new DateBetween(start, end)\n}\n","/**\n * 返回合理参数本身的函数\n * 1. 如果没有参数则返回 undefined\n * 2. 如果只有一个参数则返回参数本身\n * 3. 如果有两个以上的参数则返回参数列表\n * @param args 任何对象\n * @returns 传入的参数\n * @deprecated 已废弃，貌似没有太多的使用场景\n */\nexport function returnReasonableItself(...args: any[]): null | any | any[] {\n  const len = args.length\n  if (len === 0) {\n    return null\n  }\n  if (len === 1) {\n    return args[0]\n  }\n  return args\n}\n","import { returnItself } from './../function/returnItself'\nimport { ArrayKFn } from '../interface/ArrayKFn'\nimport { getKFn } from './getKFn'\n\n/**\n * 从数组中移除指定的元素\n * 注: 时间复杂度为 1~3On\n * @param arr 需要被过滤的数组\n * @param deleteItems 要过滤的元素数组\n * @param k 每个元素的唯一键函数\n */\nexport function filterItems<T, K>(\n  arr: T[],\n  deleteItems: T[],\n  k: ArrayKFn<T, K> = returnItself,\n) {\n  const kFn = getKFn(k)\n  const kSet = new Set(deleteItems.map(kFn))\n  return arr.filter((v, i, arr) => !kSet.has(kFn(v, i, arr)))\n}\n","import { returnItself } from '../function/returnItself'\nimport { ArrayKFn } from '../interface/ArrayKFn'\nimport { getKFn } from './getKFn'\n\n/**\n * 数组之间的差异结果对象结构接口\n * left 第一个数组独有的元素列表\n * right 第二个数组独有的元素列表\n * common 两个数组共有的元素列表。注意: 这里的元素实质上是从第一个集合获取的\n */\nexport interface IArrayDiff<L, R> {\n  left: L[]\n  right: R[]\n  common: L[]\n}\n/**\n * 比较两个数组的差异\n * @param left 第一个数组\n * @param right 第二个数组\n * @param k 每个元素的唯一标识产生函数\n * @returns 比较的差异结果\n */\nexport function diffBy<L, R>(\n  left: L[],\n  right: R[],\n  k: ArrayKFn<L | R, any> = returnItself,\n): IArrayDiff<L, R> {\n  const kFn = getKFn(k)\n  // 首先得到两个 kSet 集合用于过滤\n  const kThanSet = new Set(left.map(kFn))\n  const kThatSet = new Set(right.map(kFn))\n  const leftUnique = left.filter((v, ...args) => !kThatSet.has(kFn(v, ...args)))\n  const rightUnique = right.filter(\n    (v, ...args) => !kThanSet.has(kFn(v, ...args)),\n  )\n  const kLeftSet = new Set(leftUnique.map(kFn))\n  const common = left.filter((v, ...args) => !kLeftSet.has(kFn(v, ...args)))\n  return { left: leftUnique, right: rightUnique, common }\n}\n","import { diffBy } from './diffBy'\n\n/**\n * 比较两个数组的差异\n * @deprecated 已废弃，请使用更简洁的 {@link diffBy}\n */\nexport const arrayDiffBy = diffBy\n","/**\n * 使用 Generator 实现一个从 0 开始的无限自增序列\n */\nfunction* autoIncrementGenerator(): Generator {\n  for (let i = 0; ; i++) {\n    /**\n     * @returns 每次获取都返回循环中的当前迭代变量，然后暂停于此处\n     */\n    yield i\n  }\n}\n\n/**\n * 生成器对象\n */\nconst generator = autoIncrementGenerator()\n\n/**\n * 获取自增长序列的最新值\n * @returns 最新值\n */\nexport function autoIncrement(): number {\n  return generator.next().value\n}\n","/**\n * 转换接口\n * @interface\n */\nexport class IConverter {\n  /**\n   * 将字符串解析为字符串列表\n   *\n   * @param str 字符串\n   * @return {Array.<String>} 字符串列表\n   * @abstract\n   */\n  public from(str: string): string[] {\n    throw new Error('子类必须重写 from 函数')\n  }\n  /**\n   * 将字符串列表构造为字符串\n   *\n   * @param list 字符串列表\n   * @return {String} 字符串\n   * @abstract\n   */\n  public to(list: string[]): string {\n    throw new Error('子类必须重写 to 函数')\n  }\n}\n","import { IConverter } from './IConverter'\n\n/**\n * 驼峰风格解析\n */\nexport class CamelOrPascalFrom extends IConverter {\n  /**\n   * 将字符串解析为字符串列表\n   *\n   * @param str 字符串\n   * @return {Array.<String>} 字符串列表\n   * @override\n   */\n  public from(str: string): string[] {\n    const result = []\n    const len = str.length\n    let old = 0\n    for (let i = 0; i < len; i++) {\n      const c = str.charAt(i)\n      if (c >= 'A' && c <= 'Z') {\n        if (i !== 0) {\n          result.push(str.substring(old, i))\n        }\n        old = i\n      }\n    }\n    if (old !== str.length) {\n      result.push(str.substring(old, str.length))\n    }\n    return result\n  }\n}\n","import { toLowerCase } from '../toLowerCase'\nimport { toUpperCase } from '../toUpperCase'\nimport { CamelOrPascalFrom } from './CamelOrPascalFrom'\n\n/**\n * 小写开头的驼峰转换器\n *\n */\nexport class CamelConverter extends CamelOrPascalFrom {\n  /**\n   * 将字符串列表构造为字符串\n   *\n   * @param list 字符串列表\n   * @return {String} 字符串\n   * @override\n   */\n  public to(list: string[]): string {\n    return list.reduce((res, s, i) => {\n      const str = toLowerCase(s)\n      return (res +=\n        (i === 0 ? toLowerCase : toUpperCase)(str.substring(0, 1)) +\n        str.substring(1))\n    }, '')\n  }\n}\n","import { toLowerCase } from '../toLowerCase'\nimport { toUpperCase } from '../toUpperCase'\nimport { CamelOrPascalFrom } from './CamelOrPascalFrom'\n\n/**\n * 大写开头的驼峰转换器\n */\nexport class PascalConverter extends CamelOrPascalFrom {\n  /**\n   * 将字符串列表构造为字符串\n   *\n   * @param list 字符串列表\n   * @return {String} 字符串\n   * @override\n   */\n  public to(list: string[]): string {\n    return list.reduce((res, s) => {\n      const str = toLowerCase(s)\n      return (res += toUpperCase(str.substring(0, 1)) + str.substring(1))\n    }, '')\n  }\n}\n","import { IConverter } from './IConverter'\n\n/**\n * 下划线风格解析\n */\nexport class SnakeOrScreamingSnakeFrom extends IConverter {\n  /**\n   * 将字符串解析为字符串列表\n   *\n   * @param str 字符串\n   * @return {Array.<String>} 字符串列表\n   * @override\n   */\n  public from(str: string): string[] {\n    return str.split('_')\n  }\n}\n","import { toLowerCase } from '../toLowerCase'\nimport { SnakeOrScreamingSnakeFrom } from './SnakeOrScreamingSnakeFrom'\n\n/**\n * 小写下划线的转换器\n */\nexport class SnakeConverter extends SnakeOrScreamingSnakeFrom {\n  /**\n   * 将字符串列表构造为字符串\n   *\n   * @param list 字符串列表\n   * @return {String} 字符串\n   * @override\n   */\n  public to(list: string[]): string {\n    return list.map(toLowerCase).join('_')\n  }\n}\n","import { toUpperCase } from '../toUpperCase'\nimport { SnakeOrScreamingSnakeFrom } from './SnakeOrScreamingSnakeFrom'\n\n/**\n * 大写下划线的转换器\n */\nexport class ScreamingSnakeConverter extends SnakeOrScreamingSnakeFrom {\n  /**\n   * 将字符串列表构造为字符串\n   *\n   * @param list 字符串列表\n   * @return {String} 字符串\n   * @override\n   */\n  public to(list: string[]): string {\n    return list.map(toUpperCase).join('_')\n  }\n}\n","/**\n * @enum {Symbol} 字符串风格常量对象\n */\nexport enum StringStyleType {\n  /**\n   * 小写驼峰\n   */\n  Camel = 1,\n  /**\n   * 大写驼峰\n   */\n  Pascal,\n  /**\n   * 小写下划线\n   */\n  Snake,\n  /**\n   * 大写下划线\n   */\n  ScreamingSnake,\n}\n","import { IConverter } from './IConverter'\nimport { CamelConverter } from './CamelConverter'\nimport { PascalConverter } from './PascalConverter'\nimport { SnakeConverter } from './SnakeConverter'\nimport { ScreamingSnakeConverter } from './ScreamingSnakeConverter'\nimport { StringStyleType } from './StringStyleType'\n\n/**\n * 转换器工厂\n */\nexport class ConverterFactory {\n  /**\n   * 获取一个转换器实例\n   *\n   * @param styleType 转换风格，使用了 {@link stringStyleType} 定义的常量对象\n   * @return {IConverter} 转换器对象\n   * @throws 如果获取未定义过的转换器，则会抛出异常\n   */\n  public static getInstance(styleType: StringStyleType): IConverter {\n    switch (styleType) {\n      case StringStyleType.Camel:\n        return new CamelConverter()\n      case StringStyleType.Pascal:\n        return new PascalConverter()\n      case StringStyleType.Snake:\n        return new SnakeConverter()\n      case StringStyleType.ScreamingSnake:\n        return new ScreamingSnakeConverter()\n      default:\n        throw new Error('No corresponding converter found')\n    }\n  }\n}\n","import { stringValidator } from '../StringValidator'\nimport { ConverterFactory } from './ConverterFactory'\nimport { IConverter } from './IConverter'\nimport { StringStyleType } from './StringStyleType'\n\n/**\n * 字符串风格转换器\n * 请不要直接使用构造函数创建，而是用 {@link StringStyleUtil.getConverter} 来获得一个转换器\n * @private\n */\nexport class StringStyleConverter {\n  private fromConverter: IConverter\n  private toConverter: IConverter\n  /**\n   * 构造一个字符串任意风格转换器\n   * @param from 转换字符串的风格\n   * @param to 需要转换的风格\n   * @private\n   */\n  constructor(from: StringStyleType, to: StringStyleType) {\n    /**\n     * @field 解析字符串风格的转换器\n     * @type {IConverter}\n     * @private\n     */\n    this.fromConverter = ConverterFactory.getInstance(from)\n    /**\n     * @field 构造字符串风格的转换器\n     * @type {IConverter}\n     * @private\n     */\n    this.toConverter = ConverterFactory.getInstance(to)\n  }\n  /**\n   * 转换字符串的风格\n   *\n   * @param str 要转换的字符串\n   * @return {String} 转换得到的字符串\n   */\n  public convert(str: string): string {\n    if (stringValidator.isEmpty(str)) {\n      return str\n    }\n    return this.toConverter.to(this.fromConverter.from(str))\n  }\n}\n","/**\n * 内存缓存接口\n */\nexport interface BaseMemoryCache<K, V> {\n  /**\n   * 添加一个缓存\n   * @param key\n   * @param val\n   */\n  add(key: K, val: V): void\n  /**\n   * 根据 key 获取一个缓存\n   * @param key\n   */\n  get(key: K): V | undefined\n  /**\n   * 删除一个缓存\n   * @param key\n   */\n  delete(key: K): void\n  /**\n   * 判断是否有一个缓存\n   * @param key\n   */\n  has(key: K): boolean\n  /**\n   * 当前缓存数量\n   */\n  readonly size: number\n  /**\n   * 清空当前所有缓存\n   */\n  clear(): void\n}\n\ninterface MemoryCacheConfig {\n  /**\n   * 缓存的最大容量\n   */\n  limit?: number\n}\n\n/**\n * 基本缓存实现\n * 主要封装通用的 delete/size 函数\n */\nabstract class BasicMemoryCache<K, V> implements BaseMemoryCache<K, V> {\n  protected cache = new Map<K, V>()\n  protected readonly limit: number\n  constructor({ limit = Infinity }: MemoryCacheConfig = {}) {\n    if (limit <= 0) {\n      throw new Error('缓存的最大容量至少为 1')\n    }\n    this.limit = limit\n  }\n\n  delete(key: K): void {\n    this.cache.delete(key)\n  }\n\n  clear(): void {\n    this.cache.clear()\n  }\n\n  get size() {\n    return this.cache.size\n  }\n\n  abstract add(key: K, val: V): void\n  abstract get(key: K): V | undefined\n  abstract has(key: K): boolean\n}\n\n/**\n * FIFO 算法\n */\nexport class MemoryCacheFIFO<K = any, V = any> extends BasicMemoryCache<K, V> {\n  add(key: K, val: V): void {\n    const diff = this.cache.size + 1 - this.limit\n    if (diff > 0) {\n      const keys = [...this.cache.keys()].slice(0, diff)\n      keys.forEach((k) => this.delete(k))\n    }\n    this.cache.set(key, val)\n  }\n\n  delete(key: K): void {\n    this.cache.delete(key)\n  }\n\n  get(key: K): V | undefined {\n    return this.cache.get(key)\n  }\n\n  get size() {\n    return this.cache.size\n  }\n\n  has(key: K): boolean {\n    return this.cache.has(key)\n  }\n}\n\n/**\n * IFU 算法\n */\nexport class MemoryCacheLFU<K = any, V = any> extends BasicMemoryCache<K, V> {\n  private lfuMap = new Map<K, number>()\n\n  add(key: K, val: V): void {\n    const diff = this.cache.size + 1 - this.limit\n    if (diff > 0) {\n      const keys = [...this.cache.keys()]\n        .sort((k1, k2) => this.lfuMap.get(k1)! - this.lfuMap.get(k2)!)\n        .slice(0, diff)\n      keys.forEach((k) => this.delete(k))\n    }\n    this.cache.set(key, val)\n    this.lfuMap.set(key, 0)\n  }\n\n  get(key: K): V | undefined {\n    this.lfuMap.set(key, this.lfuMap.get(key)! + 1)\n    return this.cache.get(key)\n  }\n\n  has(key: K): boolean {\n    this.lfuMap.set(key, this.lfuMap.get(key)! + 1)\n    return this.cache.has(key)\n  }\n\n  delete(key: K): void {\n    super.delete(key)\n    this.lfuMap.delete(key)\n  }\n\n  clear(): void {\n    super.clear()\n    this.lfuMap.clear()\n  }\n}\n\n/**\n * LRU 算法\n */\nexport class MemoryCacheLRU<K = any, V = any> extends BasicMemoryCache<K, V> {\n  private i = 0\n  private get idx() {\n    return this.i++\n  }\n  private lruMap = new Map<K, number>()\n\n  add(key: K, val: V): void {\n    const diff = this.cache.size + 1 - this.limit\n    if (diff > 0) {\n      const keys = [...this.cache.keys()]\n        .sort((k1, k2) => this.lruMap.get(k1)! - this.lruMap.get(k2)!)\n        .slice(0, diff)\n      console.log(keys, this.lruMap)\n      keys.forEach((k) => this.delete(k))\n    }\n    this.cache.set(key, val)\n    this.lruMap.set(key, this.idx)\n  }\n\n  get(key: K): V | undefined {\n    this.lruMap.set(key, this.idx)\n    return this.cache.get(key)\n  }\n\n  has(key: K): boolean {\n    this.lruMap.set(key, this.idx)\n    return this.cache.has(key)\n  }\n\n  delete(key: K): void {\n    super.delete(key)\n    this.lruMap.delete(key)\n  }\n\n  clear(): void {\n    super.clear()\n    this.lruMap.clear()\n  }\n}\n\nexport enum MemoryCacheEnum {\n  //先进先出\n  Fifo,\n  //最少使用\n  Lfu,\n  //最近使用\n  Lru,\n}\n\n/**\n * 缓存工厂类\n */\nexport class MemoryCacheFactory {\n  static create<K = any, V = any>(\n    type: MemoryCacheEnum,\n    config?: MemoryCacheConfig,\n  ): BaseMemoryCache<K, V> {\n    switch (type) {\n      case MemoryCacheEnum.Fifo:\n        return new MemoryCacheFIFO(config)\n      case MemoryCacheEnum.Lfu:\n        return new MemoryCacheLFU(config)\n      case MemoryCacheEnum.Lru:\n        return new MemoryCacheLRU(config)\n    }\n  }\n}\n","import { compatibleAsync } from '../async/compatibleAsync'\nimport {\n  BaseMemoryCache,\n  MemoryCacheEnum,\n  MemoryCacheFactory,\n} from '../cache/MemoryCache'\nimport { Func } from 'liuli-types'\n\nconst onceOfSameParamIdentity = (fn: Func, args: any[]) =>\n  `onceOfSameParam-${fn.toString()}-${JSON.stringify(args)}`\n\n/**\n * 包装一个函数为指定参数只执行一次的函数\n * @param fn 需要包装的函数\n * @param identity 参数转换的函数，参数为需要包装函数的参数\n * @param memoryCache\n * @returns 需要被包装的函数\n */\nfunction _onceOfSameParam<Fn extends Func>(\n  fn: Fn,\n  identity = onceOfSameParamIdentity,\n  memoryCache = MemoryCacheFactory.create(MemoryCacheEnum.Fifo),\n): Fn & { origin: Fn; clear: (...keys: any[]) => void } {\n  const res = new Proxy(fn, {\n    apply(_, _this, args) {\n      const key = identity(fn, args)\n      const old = memoryCache.get(key)\n      if (old !== undefined) {\n        return old\n      }\n      const res = Reflect.apply(_, _this, args)\n      return compatibleAsync(res, (res) => {\n        memoryCache.add(key, res)\n        return res\n      })\n    },\n  })\n  return Object.assign(res, {\n    origin: fn,\n    clear(...keys: any[]): void {\n      if (keys.length) {\n        memoryCache.clear()\n      } else {\n        keys.forEach((key) => memoryCache.delete(key))\n      }\n    },\n  })\n}\n\nexport const onceOfSameParam = Object.assign(_onceOfSameParam, {\n  identity: onceOfSameParamIdentity,\n})\n","import { StringStyleConverter } from './StringConverter/StringStyleConverter'\nimport { StringStyleType } from './StringConverter/StringStyleType'\nimport { onceOfSameParam } from '../function/onceOfSameParam'\n\n/**\n * 包装获取字符串风格转换器\n * 此处采用了单例模式，每种转换器只会有一个\n *\n * @param from 解析风格\n * @param to 转换风格\n * @return {StringStyleConverter} 转换器的实例\n */\nconst _getConverter = onceOfSameParam(\n  /**\n   * @param from 解析风格\n   * @param to 转换风格\n   * @return {StringStyleConverter} 转换器的实例\n   */\n  (from: StringStyleType, to: StringStyleType): StringStyleConverter =>\n    new StringStyleConverter(from, to),\n)\n\n/**\n * 字符串风格转换工具类\n */\nexport class StringStyleUtil {\n  /**\n   * 获取一个转换器的实例\n   * 该函数获取的转换器可以任意复用，请优先使用函数\n   * @param from 解析风格\n   * @param to 转换风格\n   * @return {StringStyleConverter} 转换器的实例\n   */\n  public static getConverter(\n    from: StringStyleType,\n    to: StringStyleType,\n  ): StringStyleConverter {\n    return _getConverter(from, to)\n  }\n  /**\n   * 直接转换字符串的风格\n   * 请优先使用可以复用的 {@link StringStyleUtil.getConverter} 函数\n   * @param from 解析风格\n   * @param to 转换风格\n   * @param str 要转换的字符串\n   * @return {String} 转换得到的字符串\n   */\n  public static convert(\n    from: StringStyleType,\n    to: StringStyleType,\n    str: string,\n  ): string {\n    return StringStyleUtil.getConverter(from, to).convert(str)\n  }\n}\n","import { TypeValidator } from './TypeValidator'\n\n/**\n * 递归使对象不可变\n * @param obj 任何非空对象\n * @returns 新的不可变对象\n */\nexport function deepFreeze<T extends object>(obj: T): T {\n  const freeze = (v: any) => {\n    if (TypeValidator.isObject(v)) {\n      deepFreeze(v)\n    }\n  }\n  // 数组和对象分别处理\n  if (TypeValidator.isArray(obj)) {\n    obj.forEach(freeze)\n  } else if (TypeValidator.isObject(obj)) {\n    Object.keys(obj)\n      .map((k) => Reflect.get(obj, k))\n      .forEach(freeze)\n  }\n  return Object.freeze(obj)\n}\n","import { isNullOrUndefined } from './isNullOrUndefined'\nimport { TypeValidator } from './TypeValidator'\n\n// noinspection JSPrimitiveTypeWrapperUsage\n/**\n * 包装对象，使其成为可以任意深度调用而不会出现 undefined 调用的问题\n * 注意: 该函数不能进行递归调用（{@link JSON.stringfy}），一定会造成堆栈溢出的问题（RangeError: Maximum call stack size exceeded）\n * @param obj 任意一个 Object 对象\n * @param [defaultValue] 默认值，默认为 {}\n * @returns 包装后的对象\n */\nexport function deepProxy<T extends object = object>(\n  obj: T = {} as any,\n  defaultValue: any = new String(),\n): any {\n  const handler = {\n    get(target: object, k: PropertyKey): object {\n      let v = Reflect.get(target, k)\n      if (isNullOrUndefined(v)) {\n        v = defaultValue\n      }\n      if (TypeValidator.isFunction(v)) {\n        return v.bind(target)\n      }\n      if (!TypeValidator.isObject(v)) {\n        return v\n      }\n      return new Proxy(v, handler)\n    },\n  }\n  return new Proxy(obj, handler)\n}\n","/**\n * 柯里化后返回的函数\n */\ninterface IRFunc extends Function {\n  /**\n   * 是否为柯里化函数，默认为 true 以标识柯里化函数\n   */\n  _curry: boolean\n  /**\n   * 剩余参数的长度\n   */\n  _length: number\n  /**\n   * 重写 toString 便于调试\n   */\n  toString: () => string\n}\n\n/**\n * 将函数包装为柯里化函数\n * 注: 该函数模仿了 Lodash 的 curry 函数\n * @param fn 需要包装的函数\n * @param  {...any} args 应用的部分参数\n * @returns 包装后的函数\n * @deprecated 由于之前的理解错误，该函数在下个大版本将会被废弃，请使用命名更合适的 {@link partial}\n */\nexport function curry(fn: Function, ...args: any[]): IRFunc {\n  const realArgs = args.filter((arg) => arg !== curry._)\n  // 如果函数参数足够则调用传入的函数\n  if (realArgs.length >= fn.length) {\n    return fn(...realArgs)\n  }\n\n  /**\n   * 最终返回的函数\n   * @param otherArgs 接受任意参数\n   * @returns 返回一个函数，或者函数调用完成返回结果\n   */\n  function innerFn(...otherArgs: any[]): Function {\n    // 记录需要移除补到前面的参数\n    const removeIndexSet = new Set()\n    let i = 0\n    const newArgs = args.map((arg) => {\n      if (\n        arg !== curry._ ||\n        otherArgs[i] === undefined ||\n        otherArgs[i] === curry._\n      ) {\n        return arg\n      }\n      removeIndexSet.add(i)\n      // 每次补偿前面的 curry._ 参数计数器 +1\n      return otherArgs[i++]\n    })\n    const newOtherArgs = otherArgs.filter((_v, i) => !removeIndexSet.has(i))\n    return curry(fn, ...newArgs, ...newOtherArgs)\n  }\n  // 定义柯里化函数的剩余参数长度，便于在其他地方进行部分参数应用\n  // 注: 不使用 length 属性的原因是 length 属性\n  innerFn._length = fn.length - args.filter((arg) => arg !== curry._).length\n  // 自定义 toString 函数便于调试\n  innerFn.toString = () =>\n    `name: ${fn.name}, args: [${args.map((o) => o.toString()).join(', ')}]`\n  innerFn._curry = true\n  return innerFn\n}\n\n/**\n * 柯里化的占位符，需要应用后面的参数时使用\n * 例如 {@link curry(fn)(curry._, 1)} 意味着函数 fn 的第二个参数将被确定为 1\n */\ncurry._ = Symbol('_')\n","import { returnItself } from '../function/returnItself'\nimport { ArrayKFn } from '../interface/ArrayKFn'\nimport { getKFn } from './getKFn'\n\n/**\n * 快速根据指定函数对数组进行排序\n * TODO 此处有 bug，会改变原数组的顺序（在计算的 key 值相同的情况下）\n * 注: 使用递归实现，对于超大数组（其实前端的数组不可能特别大吧？#笑）可能造成堆栈溢出\n * @param arr 需要排序的数组\n * @param k 对数组中每个元素都产生可比较的值的函数，默认返回自身进行比较\n * @returns 排序后的新数组\n */\nexport function sortBy<T, K>(arr: T[], k: ArrayKFn<T, K> = returnItself): T[] {\n  const kFn = getKFn(k)\n  //  此处为了让 typedoc 能生成文档而不得不加上类型\n  const newArr: Array<[T, number]> = arr.map((v, i) => [v, i] as [T, number])\n  function _sort<V>(arr: V[], fn: (v1: V, v2: V) => number): V[] {\n    // 边界条件，如果传入数组的值\n    if (arr.length <= 1) {\n      return arr\n    }\n    // 根据中间值对数组分治为两个数组\n    const medianIndex = Math.floor(arr.length / 2)\n    const medianValue = arr[medianIndex]\n    const left = []\n    const right = []\n    for (let i = 0, len = arr.length; i < len; i++) {\n      if (i === medianIndex) {\n        continue\n      }\n      const v = arr[i]\n      if (fn(v, medianValue) <= 0) {\n        left.push(v)\n      } else {\n        right.push(v)\n      }\n    }\n    return _sort(left, fn).concat([medianValue]).concat(_sort(right, fn))\n  }\n  return _sort(newArr, ([t1, i1], [t2, i2]) => {\n    const k1 = kFn(t1, i1, arr)\n    const k2 = kFn(t2, i2, arr)\n    if (k1 === k2) {\n      return 0\n    } else if (k1 < k2) {\n      return -1\n    } else {\n      return 1\n    }\n  }).map(([_v, i]) => arr[i])\n}\n","import { dateFormat } from './dateFormat'\nimport { dateParse } from './dateParse'\nimport { isNullOrUndefined } from '../obj/isNullOrUndefined'\nimport { stringValidator } from '../string/StringValidator'\nimport { Nullable } from '../interface/Nullable'\n\n/**\n * 日期格式化器\n * 包含格式化为字符串和解析字符串为日期的函数\n */\nexport class DateFormatter {\n  /**\n   * 日期格式化器\n   */\n  public static dateFormatter = new DateFormatter('yyyy-MM-dd')\n  /**\n   * 时间格式化器\n   */\n  public static timeFormatter = new DateFormatter('hh:mm:ss')\n  /**\n   * 日期时间格式化器\n   */\n  public static dateTimeFormatter = new DateFormatter('yyyy-MM-dd hh:mm:ss')\n  /**\n   * 构造函数\n   * @param fmt 日期时间格式\n   */\n  constructor(private fmt: string) {}\n  /**\n   * 格式化\n   * @param date 需要格式化的日期\n   * @returns 格式化的字符串\n   */\n  public format(date: Date | null): string {\n    if (isNullOrUndefined(date)) {\n      return ''\n    }\n    return dateFormat(date!, this.fmt)\n  }\n  /**\n   * 解析字符串为日期对象\n   * @param str 字符串\n   * @returns 解析得到的日期\n   */\n  public parse(str: string | null | undefined): Nullable<Date> {\n    if (stringValidator.isEmpty(str)) {\n      return null\n    }\n    return dateParse(str!, this.fmt)\n  }\n  /**\n   * 将日期时间字符串转换为前端指定格式的字符串\n   * 主要适用场景是前端接收到后端的日期时间一般是一个字符串，然而需要自定义格式的时候还必须先创建 {@link Date} 对象才能格式化，略微繁琐，故使用该函数\n   * @param str 字符串\n   * @param parseFmt 解析的日期时间格式。默认直接使用 {@link new Date()} 创建\n   * @returns 转换后得到的字符串\n   */\n  public strFormat(str: string | null | undefined, parseFmt?: string): string {\n    if (stringValidator.isEmpty(str)) {\n      return ''\n    }\n    const date = parseFmt ? dateParse(str!, parseFmt) : new Date(str!)\n    return dateFormat(date!, this.fmt)\n  }\n}\n","import { ArrayCallback } from '../interface/ArrayCallback'\n\n/**\n * 查询符合条件的元素的下标\n * @param arr 查询的数组\n * @param fn 谓词\n * @param num 查询的第几个符合条件的元素，默认为 1，和默认的 findIndex 行为保持一致\n * @returns 符合条件的元素的下标，如果没有则返回 -1\n */\nexport function findIndex<T>(\n  arr: T[],\n  fn: ArrayCallback<T, boolean>,\n  num = 1,\n): number {\n  let k = 0\n  for (let i = 0, len = arr.length; i < len; i++) {\n    if (fn.call(arr, arr[i], i, arr) && ++k >= num) {\n      return i\n    }\n  }\n  return -1\n}\n","import { curry } from './curry'\nimport { findIndex } from '../array/findIndex'\n\n/**\n * 连接两个函数并自动柯里化\n * 注: 该函数依赖于 length，所以不支持默认参数以及不定参数\n * @param fn1 第一个函数\n * @param fn2 第二个函数\n * @returns 连接后的函数\n */\nconst _compose = (fn1: Function, fn2: Function): Function => {\n  return function (...args: any[]) {\n    const i = findIndex(\n      args,\n      (v) => v !== curry._,\n      (fn1 as any)._length || fn1.length,\n    )\n    const res = curry(fn1, ...args)\n    // 如果这个函数的参数不足，则返回它\n    if (i === -1) {\n      return _compose(res, fn2)\n    }\n    // 否则将结果以及多余的参数应用到下一个函数上\n    return curry(fn2, res, ...args.slice(i + 1))\n  }\n}\n\n/**\n * 将多个函数组合起来\n * 前面函数的返回值将变成后面函数的第一个参数，如果到了最后一个函数执行完成，则直接返回\n * 注: 该函数是自动柯里化，将对所有传入的函数进行柯里化处理\n * 注: 该函数支持一次调用传入全部函数的参数\n * @param fns 多个需要连接函数\n * @returns 连接后的柯里化函数\n * TODO 这里需要进行类型优化\n */\nexport function compose(...fns: Function[]): Function {\n  return fns.reduceRight((fn1, fn2) => _compose(fn2, fn1))\n}\n","import { excludeFields } from './excludeFields'\nimport { TypeValidator } from './TypeValidator'\n\n/**\n * 递归排除对象中的指定字段\n * @param obj 需要排除的对象\n * @param  {...obj} fields 需要排除的字段\n */\nexport function deepExcludeFields<T extends object>(\n  obj: T,\n  ...fields: PropertyKey[]\n): T {\n  if (TypeValidator.isArray(obj)) {\n    return obj.map((o) => deepExcludeFields(o, ...fields)) as any\n  } else if (TypeValidator.isDate(obj)) {\n    return obj\n  } else if (TypeValidator.isObject(obj)) {\n    const temp = excludeFields(obj, ...(fields as any))\n    return Object.keys(temp).reduce((res, k) => {\n      const v = Reflect.get(res, k)\n      Reflect.set(res, k, deepExcludeFields(v, ...fields))\n      return res\n    }, temp) as any\n  } else {\n    return obj\n  }\n}\n","import { deepExcludeFields } from './deepExcludeFields'\n\n/**\n * 递归排除对象中的指定字段\n * @param obj 需要排除的对象\n * @param  {...obj} fields 需要排除的字段\n * @deprecated 已废弃，请使用统一使用 `deep` 开头的 {@link deepExcludeFields} 函数\n */\nexport function excludeFieldsDeep<T extends object>(\n  obj: T,\n  ...fields: PropertyKey[]\n): T {\n  return deepExcludeFields(obj, ...fields)\n}\n","import { ICacheOption } from './ICacheOption'\n\n/**\n * 缓存值的构造函数对象参数定义接口\n */\ninterface ICacheValInit {\n  /**\n   * 缓存的 key 值\n   */\n  key: string\n  /**\n   * 缓存的 value\n   */\n  val: any\n  /**\n   * 缓存的选项\n   */\n  cacheOption: ICacheOption\n}\n\n/**\n * 缓存的值\n */\nexport class CacheVal implements ICacheValInit {\n  public key!: string\n  public val: any\n  public cacheOption!: ICacheOption\n  /**\n   * 构造函数\n   * @param options 缓存值对象\n   * @param options.key 缓存的键原始值\n   * @param options.val 缓存的值\n   * @param options.cacheOption 缓存的选项\n   */\n  constructor(options: Partial<ICacheValInit> = {}) {\n    Object.assign(this, options)\n  }\n}\n","/**\n * 无限的超时时间\n * TODO 此处暂时使用字符串作为一种折衷方法，因为 Symbol 无法被序列化为 JSON，反向序列化也是不可能的\n */\nexport const TimeoutInfinite = 'TimeoutInfinite'\n\n/**\n * 缓存选项\n * @param options.timeout 超时时间，以毫秒为单位\n * @param options.timeStart 缓存开始时间\n * @param options.serialize 缓存序列化\n * @param options.deserialize 缓存反序列化\n */\nexport interface ICacheOption {\n  timeout: number | string\n  timeStart: number\n  serialize: (val: any) => string\n  deserialize: (s: string) => any\n}\n","import { ICache } from './ICache'\nimport { CacheVal } from './CacheVal'\nimport { ICacheOption, TimeoutInfinite } from './ICacheOption'\nimport { safeExec } from '../function/safeExec'\nimport { isNullOrUndefined } from '../obj/isNullOrUndefined'\nimport { not } from '../function/CombinedPredicate'\n\n/**\n * 使用 LocalStorage 实现的缓存\n * 1. get: 根据 key 获取\n * 2. set: 根据 key value 设置，会覆盖\n * 3. touch: 获取并刷新超时时间\n * 4. add: 根据 key value 添加，不会覆盖\n * 5. del: 根据 key 删除\n * 6. clearExpired: 清除所有过期的缓存\n */\nexport class LocalStorageCache<T> implements ICache<T> {\n  public localStorage: Storage\n  public cacheOption: ICacheOption\n  /**\n   * 构造函数\n   * @param cacheOption 全局缓存选项\n   */\n  constructor({\n    timeout = TimeoutInfinite,\n    serialize = JSON.stringify,\n    deserialize = JSON.parse,\n  }: Partial<ICacheOption> = {}) {\n    // 这里必须强制转换，因为 timeStart 在全局选项中是不可能存在的\n    this.cacheOption = {\n      timeout,\n      serialize,\n      deserialize,\n    } as any\n    /**\n     * 缓存对象，默认使用 localStorage\n     */\n    this.localStorage = window.localStorage\n    // 创建后将异步清空所有过期的缓存\n    this.clearExpired()\n  }\n  /**\n   * 清空所有过期的 key\n   * 注: 该函数是异步执行的\n   */\n  public async clearExpired() {\n    const local = this.localStorage\n    const getKeys = () => {\n      const len = local.length\n      const res = []\n      for (let i = 0; i < len; i++) {\n        res.push(local.key(i))\n      }\n      return res\n    }\n    getKeys()\n      .filter(not(isNullOrUndefined))\n      .map((key) => safeExec(() => JSON.parse(local.getItem(key!)!)))\n      .filter(\n        (cacheVal) =>\n          !isNullOrUndefined(cacheVal) &&\n          isNullOrUndefined(cacheVal.cacheOption),\n      )\n      // TODO 这里暂时加个补丁，过滤掉 timeStart,timeout 为 undefined 的缓存\n      .filter(({ cacheOption = {} as any }: CacheVal) => {\n        const { timeStart, timeout } = cacheOption\n        if (isNullOrUndefined(timeStart) || isNullOrUndefined(timeout)) {\n          return false\n        }\n        return timeout !== TimeoutInfinite && Date.now() - timeStart > timeout\n      })\n      .forEach(({ key }: CacheVal) => local.removeItem(key))\n  }\n  /**\n   * 根据 key + value 添加\n   * 如果不存在则添加，否则忽略\n   * @param key 缓存的 key\n   * @param val 缓存的 value\n   * @param cacheOption 缓存的选项，默认为无限时间\n   * @override\n   */\n  public add(key: string, val: T, timeout?: number) {\n    const result = this.get(key)\n    if (result !== null) {\n      return\n    }\n    this.set(key, val, timeout)\n  }\n  /**\n   * 根据指定的 key 删除\n   * 如果存在则删除，否则忽略\n   * @param key 删除的 key\n   * @override\n   */\n  public del(key: string) {\n    this.localStorage.removeItem(key)\n  }\n  /**\n   * 根据指定的 key 修改\n   * 不管是否存在都会设置\n   * @param key 修改的 key\n   * @param val 修改的 value\n   * @param timeout 修改的选项\n   * @override\n   */\n  public set(key: string, val: T, timeout?: number) {\n    this.localStorage.setItem(\n      key,\n      JSON.stringify(\n        new CacheVal({\n          key,\n          val: this.cacheOption.serialize(val),\n          // 我们不需要缓存序列化/反序列化策略（实际上也无法缓存）\n          cacheOption: {\n            timeStart: Date.now(),\n            timeout: timeout || this.cacheOption.timeout,\n          } as any,\n        }),\n      ),\n    )\n  }\n  /**\n   * 根据 key 获取\n   * 如果存在则获取，否则忽略\n   * @param key 指定的 key\n   * @param timeout 获取的选项\n   * @returns 获取到的缓存值\n   * @override\n   */\n  public get(key: string): T | null {\n    const str = this.localStorage.getItem(key)\n    const cacheVal: CacheVal = safeExec(() => JSON.parse(str!))\n    if (\n      isNullOrUndefined(cacheVal) ||\n      isNullOrUndefined(cacheVal.cacheOption)\n    ) {\n      return null\n    }\n    const [timeStart, timeout, deserialize] = [\n      cacheVal.cacheOption.timeStart,\n      cacheVal.cacheOption.timeout,\n      this.cacheOption.deserialize,\n    ]\n    // 如果超时则删除并返回 null\n    if (timeout !== TimeoutInfinite && Date.now() - timeStart > timeout) {\n      this.del(key)\n      return null\n    }\n    try {\n      return deserialize(cacheVal.val)\n    } catch (e) {\n      this.del(key)\n      return null\n    }\n  }\n  /**\n   * 根据 key 获取并刷新超时时间\n   * @param key 指定的 key\n   * @param cacheOption 获取的选项\n   * @returns 获取到的缓存值\n   * @override\n   */\n  public touch(key: string): T | null {\n    const str = this.localStorage.getItem(key)\n    /**\n     * @type {CacheVal}\n     */\n    const cacheVal: CacheVal = safeExec(() => JSON.parse(str!))\n    if (\n      isNullOrUndefined(cacheVal) ||\n      isNullOrUndefined(cacheVal.cacheOption)\n    ) {\n      return null\n    }\n    const [timeStart, timeout, deserialize] = [\n      cacheVal.cacheOption.timeStart,\n      cacheVal.cacheOption.timeout,\n      this.cacheOption.deserialize,\n    ]\n    // 如果超时则删除并返回 null\n    if (timeout !== TimeoutInfinite && Date.now() - timeStart! > timeout) {\n      this.del(key)\n      return null\n    }\n    try {\n      const result = deserialize(cacheVal.val)\n      this.set(key, result, { timeStart: Date.now(), timeout } as any)\n      return result\n    } catch (e) {\n      this.del(key)\n      return null\n    }\n  }\n}\n","import { LocalStorageCache } from './LocalStorageCache'\nimport { ReturnFunc } from '../interface/ReturnFunc'\nimport { compatibleAsync } from '../async/compatibleAsync'\n\n/**\n * 默认使用的 {@link ICache} 接口的缓存实现\n */\nconst cache = new LocalStorageCache()\n\n/**\n * 缓存工具类可选参数项类型\n */\ninterface ICacheUtilOptions {\n  /**\n   * 函数唯一标识，默认为函数 toString()\n   */\n  identity: string\n  /**\n   * 缓存超时时间，默认为无限\n   */\n  timeout: number\n}\n\n/**\n * 缓存后的函数\n */\ninterface ICacheFunc<R> extends ReturnFunc<R> {\n  /**\n   * 所包装的原函数\n   * @type {Function}\n   */\n  origin: ReturnFunc<R>\n  /**\n   * 清空缓存，清空指定参数调用时的函数缓存\n   * @type {Function}\n   */\n  clear: ReturnFunc<void>\n}\n/**\n * 缓存工具类\n * 主要实现缓存高阶函数的封装\n */\nexport class CacheUtil {\n  /**\n   * 将指定函数包装为只调用一次为缓存函数\n   * @param fn 需要包装的函数\n   * @param options 缓存选项对象。可选项\n   * @param options.identity 缓存标识。默认为函数 {@link toString}，但有时候不太可行（继承自基类的函数）\n   * @param options.timeout 缓存时间。默认为无限\n   * @returns 包装后的函数\n   */\n  public static once<R>(\n    fn: ReturnFunc<R>,\n    { identity = fn.toString(), timeout }: Partial<ICacheUtilOptions> = {},\n  ): ICacheFunc<R> {\n    const generateKey = () => `CacheUtil.onceOfSameParam-${identity}`\n    const innerFn = new Proxy(fn, {\n      apply(_, _this, args) {\n        const key = generateKey()\n        const val = cache.get(key)\n        if (val !== null) {\n          return val\n        }\n        return compatibleAsync(Reflect.apply(_, _this, args), (res) => {\n          cache.set(key, res, timeout)\n          return res\n        })\n      },\n    })\n    return Object.assign(innerFn, {\n      origin: fn,\n      clear(): void {\n        cache.del(generateKey())\n      },\n    })\n  }\n  /**\n   * 包裹函数为缓存函数\n   * @param fn 一个接受一些参数并返回结果的函数\n   * @param options 缓存选项对象。可选项\n   * @param options.identity 缓存标识。默认为函数 {@link toString}，但有时候不太可行（继承自基类的函数）\n   * @param options.timeout 缓存时间。默认为无限\n   * @returns 带有缓存功能的函数\n   */\n  public static onceOfSameParam<R>(\n    fn: ReturnFunc<R>,\n    { identity = fn.toString(), timeout }: Partial<ICacheUtilOptions> = {},\n  ): ICacheFunc<R> {\n    const generateKey = (args: any[]) =>\n      `CacheUtil.onceOfSameParam-${identity}-${JSON.stringify(args)}`\n    const innerFn = new Proxy(fn, {\n      apply(_, _this, args) {\n        const key = generateKey(args)\n        const val = cache.get(key)\n        if (val !== null) {\n          return val\n        }\n        return compatibleAsync(Reflect.apply(_, _this, args), (res) => {\n          cache.set(key, res, timeout)\n          return res\n        })\n      },\n    })\n    return Object.assign(innerFn, {\n      origin: fn,\n      clear(...args: any): void {\n        cache.del(generateKey(args))\n      },\n    })\n  }\n}\n\n/**\n * 导出一个默认的缓存工具对象\n * @deprecated 已废弃，请直接使用类的静态函数\n */\nexport const cacheUtil = CacheUtil\n","/**\n * 一个空的函数\n * @param args 接受任何参数\n */\nexport function emptyFunc(...args: any[]) {}\n","import { timing } from '../function/timing'\nimport { emptyFunc } from '../function/emptyFunc'\nimport { returnItself } from '../function/returnItself'\nimport { arrayToMap } from '../array/arrayToMap'\nimport { EmptyFunc } from '../interface/EmptyFunc'\n\n/**\n * 禁止他人调试网站相关方法的集合对象\n */\nexport class AntiDebug {\n  /**\n   * 不停循环 debugger 防止有人调试代码\n   * @returns 取消函数\n   */\n  public static cyclingDebugger(): EmptyFunc {\n    const res = setInterval(() => {\n      debugger\n    }, 100)\n    return () => clearInterval(res)\n  }\n\n  /**\n   * 检查是否正在 debugger 并调用回调函数\n   * @param fn 回调函数，默认为重载页面\n   * @returns 取消函数\n   */\n  public static checkDebug(\n    fn: Function = () => window.location.reload(),\n  ): EmptyFunc {\n    const res = setInterval(() => {\n      const diff = timing(() => {\n        debugger\n      })\n      if (diff > 500) {\n        console.log(diff)\n        fn()\n      }\n    }, 1000)\n    return () => clearInterval(res)\n  }\n\n  /**\n   * 禁用控制台调试输出\n   * @returns 取消函数\n   */\n  public static disableConsoleOutput(): EmptyFunc {\n    if (!window.console) {\n      return emptyFunc\n    }\n    const map = arrayToMap(Object.keys(console), returnItself, (k) => {\n      // @ts-ignore\n      const temp = console[k]\n      // @ts-ignore\n      console[k] = emptyFunc\n      return temp\n    })\n    return () => {\n      for (const [k, v] of map) {\n        // @ts-ignore\n        console[k] = v\n      }\n    }\n  }\n}\n/**\n * 禁止他人调试网站相关方法的集合对象\n * @deprecated 已废弃，请直接使用类的静态函数\n */\nexport const antiDebug = AntiDebug\n","import { stringValidator } from './StringValidator'\n\n/**\n * 判断一个字符串是否为空白的字符串\n * @param str 字符串\n * @returns 是否为空字符串\n * @deprecated 已废弃，请使用 {@link stringValidator#isBlank}\n */\nexport function isBlank(str: any): boolean {\n  return stringValidator.isBlank(str)\n}\n","import { stringValidator } from './StringValidator'\n\n/**\n * 判断一个字符串是否为空字符串\n * @param str 字符串\n * @returns 是否为空字符串\n * @deprecated 已废弃，请使用 {@link stringValidator#isEmpty}\n */\nexport function isEmpty(str: any): boolean {\n  return stringValidator.isEmpty(str)\n}\n","/**\n * 加载一个远程脚本文件\n * @param src 远程脚本路径\n * @returns 等待异步加载脚本完成\n */\nexport function loadScript(src: string): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const script = document.createElement('script')\n    script.async = false\n    script.src = src\n    script.addEventListener('load', () => resolve())\n    script.addEventListener('error', reject)\n    document.body.appendChild(script)\n  })\n}\n","import { CombinedPredicate } from './CombinedPredicate'\nimport { PredicateFunc } from '../interface/PredicateFunc'\n\n/**\n * 将一个谓词函数取反\n * 如果是同步函数，则返回的函数也是同步的，否则返回的是取反后的异步函数\n * @param fn 要取反的函数\n * @returns 取反得到的函数\n * @deprecated 已废弃，请使用 {@link CombinedPredicate.not} 进行为此取反\n */\nexport function deny(fn: PredicateFunc): PredicateFunc {\n  return CombinedPredicate.not(fn)\n}\n","import { isNullOrUndefined } from '../obj/isNullOrUndefined'\n\n/**\n * 数组校验器\n */\nexport class ArrayValidator {\n  /**\n   * 是否为空数组\n   * @param array 空数组\n   * @returns 是否为空数组\n   */\n  public static isEmpty(array: any[] | null | undefined): boolean {\n    return (\n      isNullOrUndefined(array) ||\n      !(array instanceof Array) ||\n      array.length === 0\n    )\n  }\n}\n\n/**\n * 导出一个默认的数组校验对象\n * @deprecated 已废弃，请直接使用类的静态函数\n */\nexport const arrayValidator = ArrayValidator\n","/**\n * 路径工具\n */\nexport class PathUtil {\n  /**\n   * 拼接多个路径\n   *\n   * @param paths 路径数组\n   * @return {String} 拼接完成的路径\n   */\n  public static join(...paths: string[]): string {\n    return paths.reduce(PathUtil._join)\n  }\n  /**\n   * 路径分隔符\n   */\n  private static Separator = '/'\n  /**\n   * 拼接两个路径\n   *\n   * @param pathStart 开始路径\n   * @param pathEnd   结束路径\n   * @return {String} 拼接完成的两个路径\n   */\n  private static _join(pathStart: string, pathEnd: string): string {\n    if (pathStart.endsWith(PathUtil.Separator)) {\n      return (pathStart + pathEnd).replace(\n        PathUtil.Separator + PathUtil.Separator,\n        PathUtil.Separator,\n      )\n    }\n    if (pathEnd.startsWith(PathUtil.Separator)) {\n      return pathStart + pathEnd\n    }\n    return pathStart + PathUtil.Separator + pathEnd\n  }\n}\n\n/**\n * 导出一个路径工具类\n * @deprecated 已废弃，请直接使用类的静态函数\n */\nexport const pathUtil = PathUtil\n","import { emptyFunc } from '../function/emptyFunc'\n\nenum LoggerLevelEnum {\n  Debug = 0,\n  Log,\n  Info,\n  Warn,\n  Error,\n}\n\nconst enumMap: Partial<Record<keyof typeof console, LoggerLevelEnum>> = {\n  debug: LoggerLevelEnum.Debug,\n  log: LoggerLevelEnum.Log,\n  info: LoggerLevelEnum.Info,\n  warn: LoggerLevelEnum.Warn,\n  error: LoggerLevelEnum.Error,\n}\n\n/**\n * 自定义的日志类\n * 主要便于在开发环境下正常显示调试信息，在生产环境则默认关闭它\n */\nexport class Logger {\n  static Level = LoggerLevelEnum\n  /**\n   * 设置 enable 的 setter 属性，在改变时合并对应的子类对象实现\n   * @param enable 是否开启\n   */\n  set enable(enable: boolean) {\n    /**\n     * @field 是否开启全局控制台，该属性只写\n     */\n    ;(Object.keys(console) as (keyof typeof console)[]).forEach((k) =>\n      Reflect.set(this, k, enable ? console[k] : emptyFunc),\n    )\n  }\n\n  /**\n   * 设置日志的级别\n   * @param level\n   */\n  set level(level: LoggerLevelEnum) {\n    ;(Object.keys(console) as (keyof typeof console)[])\n      .filter((k) => Reflect.has(enumMap, k))\n      .forEach((k) =>\n        Reflect.set(\n          this,\n          k,\n          Reflect.get(enumMap, k) >= level ? console[k] : emptyFunc,\n        ),\n      )\n  }\n\n  /**\n   * 开发日志：业务强相关调试日志，希望其他人开发时默认隐藏起来的日志（例如第三方服务的回调日志很多，但对于服务接入层的使用者并不关心）\n   */\n  debug = console.debug\n  /**\n   * 开发日志：业务相关调试日志，希望其他开发时也能看到的日志\n   */\n  log = console.log\n  /**\n   * 生产日志：开发环境也会打印的日志，希望在生产环境打印并且方便调试的日志\n   */\n  info = console.info\n  /**\n   * 警告日志：一些危险的操作可以在这里打印出来，同时会显示在生产环境（例如警告用户不要在控制台输入不了解的代码以避免账号安全）\n   */\n  warn = console.warn\n  /**\n   * 错误日志：发生错误时使用的日志，发生影响到用户的错误时必须使用该日志\n   */\n  error = console.error\n\n  dir = console.dir\n  dirxml = console.dirxml\n  table = console.table\n  trace = console.trace\n  group = console.group\n  groupCollapsed = console.groupCollapsed\n  groupEnd = console.groupEnd\n  clear = console.clear\n  count = console.count\n  assert = console.assert\n  time = console.time\n  timeEnd = console.timeEnd\n  timeStamp = console.timeStamp\n\n  /**\n   * 构造函数\n   * @param options 可选项\n   * @param options.enable 是否开启日志\n   */\n  constructor(\n    {\n      enable = true,\n      level = LoggerLevelEnum.Log,\n    }: Pick<Logger, 'enable' | 'level'> = {} as any,\n  ) {\n    this.enable = enable\n    this.level = level\n  }\n}\n\n/**\n * 导出一个全局可用的 Logger 对象\n * 使用 enable 属性控制是否开启日志输出，默认为 true\n */\nexport const logger = new Logger()\n","/**\n * 将 Object 对象 转换为 Map\n * @param obj Object 对象\n * @returns 转换得到的 Map 键值表\n */\nexport function objectToMap(\n  obj: Record<PropertyKey, any>,\n): Map<PropertyKey, any> {\n  return Object.keys(obj).reduce(\n    (map, k) => map.set(k, Reflect.get(obj, k)),\n    new Map(),\n  )\n}\n","import { returnItself } from '../function/returnItself'\nimport { INode } from './INode'\n\n/**\n * 列表转树可选项对象\n */\nexport interface IListToTreeOptoins<T> {\n  /**\n   * 桥接函数，默认返回自身\n   */\n  bridge?: (node: T) => INode\n  /**\n   * 判断节点是否为根节点。默认根节点的父节点为空\n   */\n  isRoot?: (node: INode) => boolean\n}\n\n/**\n * 将列表转换为树节点\n * 注: 该函数默认树的根节点只有一个，如果有多个，则返回一个数组\n * @param list 树节点列表\n * @param options 其他选项\n * @returns 树节点，或是树节点列表\n */\nexport function listToTree<T>(\n  list: T[],\n  {\n    bridge = returnItself,\n    isRoot = (node) => !node.parentId,\n  }: Partial<IListToTreeOptoins<T>> = {},\n): INode | INode[] | object {\n  const arr: INode[] = []\n  const res = list.reduce((root, _sub) => {\n    const sub = bridge!(_sub)\n    if (isRoot(sub)) {\n      root.push(sub)\n      return root\n    }\n    for (const _parent of list) {\n      const parent = bridge!(_parent)\n      if (sub.parentId === parent.id) {\n        parent.child = parent.child || []\n        parent.child.push(sub)\n        return root\n      }\n    }\n    return root\n  }, arr)\n  // 根据顶级节点的数量决定如何返回\n  const len = res.length\n  if (len === 0) return {}\n  if (len === 1) return res[0]\n  return res\n}\n","/**\n * 桥接对象不存在的字段\n * @param map 代理的字段映射 Map\n * @returns 转换一个对象为代理对象\n * @typeparam 类型解释：1. -readonly 是将使用者的 as const 修改为可变的字段，2. [P in keyof M] 从映射对象中取出所有的 key 作为字段，3. T[M[P] extends keyof T ? M[P] : never] 本质上只是 T[M[P]]]，只是 ts 不认为 M[P] 是 T 的字段，所以只能绕一下才能使用\n */\nexport function bridge<M extends object>(\n  map: M,\n): <T extends object>(\n  obj: T,\n) => T &\n  {\n    -readonly [P in keyof M]: T[M[P] extends keyof T ? M[P] : never]\n  } {\n  /**\n   * 为对象添加代理的函数\n   * @param obj 任何对象\n   * @returns 代理后的对象\n   */\n  return function (obj: any): any {\n    return new Proxy(obj as any, {\n      get(_, k) {\n        if (Reflect.has(map, k)) {\n          return Reflect.get(_, Reflect.get(map, k))\n        }\n        return Reflect.get(_, k)\n      },\n      set(_, k, v) {\n        if (Reflect.has(map, k)) {\n          Reflect.set(_, Reflect.get(map, k), v)\n          return true\n        }\n        Reflect.set(_, k, v)\n        return true\n      },\n    })\n  }\n}\n","import { arrayValidator } from '../array/ArrayValidator'\nimport { returnItself } from '../function/returnItself'\nimport { INode } from './INode'\n\n/**\n * 遍历并映射一棵树的可选参数对象\n */\ninterface ITreeMappingOptions<T> {\n  /**\n   * 遍历子节点之前的操作。默认返回自身\n   */\n  before?: (node: T, ...args: any[]) => INode\n  /**\n   * 遍历子节点之后的操作。默认返回自身\n   */\n  after?: (node: INode, ...args: any[]) => INode\n  /**\n   * 递归的参数生成函数。默认返回一个空数组\n   */\n  paramFn?: (node: INode, ...args: any[]) => any[]\n}\n\n/**\n * 遍历并映射一棵树的每个节点\n * @param root 树节点\n * @param options 其他选项\n * @returns 递归遍历后的树节点\n */\nexport function treeMapping<T>(\n  root: T,\n  {\n    before = returnItself,\n    after = returnItself,\n    paramFn = (node, ...args) => [],\n  }: Partial<ITreeMappingOptions<T>> = {},\n): INode {\n  /**\n   * 遍历一颗完整的树\n   * @param node 要遍历的树节点\n   * @param args 每次递归遍历时的参数\n   */\n  function _treeMapping(node: any, ...args: any[]): INode {\n    // 之前的操作\n    const _node = before!(node, ...args)\n    const _child = _node.child\n    if (!arrayValidator.isEmpty(_child)) {\n      _node.child = _child.map((v) =>\n        // 产生一个参数\n        _treeMapping(v, ...paramFn(_node, ...args)),\n      )\n    }\n    // 之后的操作\n    return after(_node, ...args)\n  }\n  return _treeMapping(root)\n}\n","import { returnItself } from '../function/returnItself'\nimport { treeMapping } from './treeMapping'\nimport { INode } from './INode'\nimport { ArrayValidator } from '../array/ArrayValidator'\nimport { isNullOrUndefined } from '../obj/isNullOrUndefined'\n\n/**\n * 树转列表可选项参数接口\n */\ninterface ITreeToListOptoins<T> {\n  /**\n   * 是否计算节点全路径，默认为 false\n   */\n  calcPath?: boolean\n  /**\n   * 桥接函数，默认返回自身\n   */\n  bridge?: (node: T) => INode\n}\n\n/**\n * 将树节点转为树节点列表\n * 存在错误\n * @param root 树节点\n * @param options 其他选项\n * @returns 树节点列表\n */\nexport function treeToList2<T>(\n  root: T,\n  {\n    calcPath = false,\n    bridge = returnItself,\n  }: Partial<ITreeToListOptoins<T>> = {},\n): INode[] {\n  const res: INode[] = []\n  const filterSet = new Set<T>()\n  let i = 0\n  // @ts-ignore\n  treeMapping(root, {\n    before(_node, parentPath) {\n      // @ts-ignore\n      console.log(++i, _node)\n      const node = bridge!(_node)\n      if (filterSet.has(_node)) {\n        return node\n      }\n      filterSet.add(_node)\n      // 是否计算全路径\n      if (calcPath) {\n        node.path = (parentPath ? parentPath + ',' : '') + node.id\n      }\n      // 此时追加到数组中\n      res.push(node)\n      return node\n    },\n    paramFn: (node) => (calcPath ? [node.path] : []),\n  })\n  return res\n}\n\n/**\n * 将树节点转为树节点列表\n * 这里使用了循环进行遍历，而非传统的递归方式\n * @param root 树节点\n * @param options 其他选项\n * @returns 树节点列表\n */\nexport function treeToList<T>(\n  root: T,\n  {\n    calcPath = false,\n    bridge = returnItself,\n  }: Partial<ITreeToListOptoins<T>> = {},\n): INode[] {\n  const res: INode[] = []\n  const temp = bridge(root)\n  if (calcPath) {\n    temp.path = temp.id + ''\n  }\n  // 利用队列缓存所有未处理的节点\n  const queue: INode[] = [temp]\n  // 使用 Set 防止可能的重复引用\n  const filterSet = new Set<INode>()\n  // 使用 lastIdMap 避免重复添加\n  const lastIdMap = new Map()\n  for (let value: INode; queue.length > 0; ) {\n    const first = queue.shift() as any\n    value = bridge(first)\n    // 判断重复\n    if (value === undefined || filterSet.has(first)) {\n      continue\n    }\n    filterSet.add(first)\n    res.push(value)\n    const child = value.child\n    if (ArrayValidator.isEmpty(child)) {\n      continue\n    }\n    const childNonIllegal = child.filter(\n      (v) => !isNullOrUndefined(v) || filterSet.has(v),\n    )\n    // TODO 这里和上面的代码明显重复，待优化。。。\n    queue.push(\n      ...(calcPath\n        ? childNonIllegal.map((v) => {\n            const _v = bridge(v as any)\n            // 如果最后一个的 id 等于自身，说明已经被添加过了\n            if (lastIdMap.get(_v.id) === _v.id) {\n              return _v\n            }\n            // 使用父节点绝对路径 + 当前 id\n            _v.path = value.path + ',' + _v.id\n            lastIdMap.set(_v.id, _v.id)\n            return _v\n          })\n        : childNonIllegal),\n    )\n  }\n  return res\n}\n","import { bridge } from '../function/bridge'\nimport { INodeBridge } from './INodeBridge'\nimport { treeMapping } from './treeMapping'\nimport { INode } from './INode'\n\n/**\n * 树节点桥接工具类\n * 主要实现了桥接 {@field bridge} {@field bridgeTree} 和 {@field bridgeList} 三个函数，事实上桥接之后再转换相当于做了两遍，但就目前而言暂且只能如此了\n */\n\nexport class NodeBridgeUtil {\n  /**\n   * 桥接对象为标准的树结构\n   * @param nodeBridge 桥接对象\n   * @returns 代理函数\n   */\n  public static bridge<T>({\n    id = 'id',\n    parentId = 'parentId',\n    child = 'child',\n    path = 'path',\n  }: Partial<INodeBridge> = {}): (node: T) => INode {\n    return bridge({\n      id,\n      parentId,\n      child,\n      path,\n    }) as any\n  }\n  /**\n   * 桥接一棵完整的树\n   * @param tree 树节点\n   * @param nodeBridge 桥接对象\n   * @returns 代理后的树对象\n   */\n  public static bridgeTree<T>(tree: T, nodeBridge?: INodeBridge): INode {\n    return treeMapping(tree, {\n      before: this.bridge(nodeBridge),\n    })\n  }\n  /**\n   * 桥接一个树节点列表\n   * @param list 树节点列表\n   * @param nodeBridge 桥接对象\n   * @returns 代理后的树节点列表\n   */\n  public static bridgeList<T>(list: T[], nodeBridge?: INodeBridge): INode[] {\n    return list.map(this.bridge(nodeBridge))\n  }\n}\n\n/**\n * 导出一个 NodeBridgeUtil 的实例\n * @deprecated 已废弃，请直接使用类的静态函数\n */\nexport const nodeBridgeUtil = NodeBridgeUtil\n","/**\n * 获取对象中所有的属性及对应的值，包括 ES6 新增的 Symbol 类型的属性\n * @param obj 任何对象\n * @returns 属性及其对应值的二维数组\n * @deprecated 该函数将要被废弃，实质上应用场景很窄\n */\nexport function getObjectEntries(obj: object): Array<[PropertyKey, any]> {\n  const mFn: (k: PropertyKey) => [PropertyKey, any] = (k) => [\n    k,\n    Reflect.get(obj, k),\n  ]\n  return Reflect.ownKeys(obj).map(mFn)\n}\n","import { isNullOrUndefined } from './isNullOrUndefined'\n\n/**\n * 获取对象中所有的属性，包括 ES6 新增的 Symbol 类型的属性\n * @param obj 任何对象\n * @returns 属性数组\n * @deprecated 已废弃，请使用 ES6 {@see Reflect.ownKeys} 代替\n * 具体参考 {@url(https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys)}\n */\nexport function getObjectKeys(obj: object | undefined | null): PropertyKey[] {\n  if (isNullOrUndefined(obj)) {\n    return []\n  }\n  return Reflect.ownKeys(obj!)\n}\n","/**\n * 比较两个浮点数是否相等\n * 具体实现采用差值取绝对值并与 {@link Number.EPSILON} 比较的方式，如果小于浮点数最小差值，则认为它们是 [相等] 的\n * @param num1 第一个浮点数\n * @param num2 第二个浮点数\n * @returns 两数是否相等\n */\nexport function floatEquals(num1: number, num2: number): boolean {\n  return Math.abs(num1 - num2) < Number.EPSILON\n}\n","import { isNullOrUndefined } from './isNullOrUndefined'\n\n//TODO 暂时绕过类型错误，之后有时间再修\n// export function assign<T, A>(target: T, a: A): T & A\n// export function assign<T, A, B>(target: T, a: A, b: B): T & A & B\n// export function assign<T, A, B, C>(target: T, a: A, b: B, c: C): T & A & B & C\n// export function assign<T, A, B, C, D>(\n//   target: T,\n//   a: A,\n//   b: B,\n//   c: C,\n//   d: D,\n// ): T & A & B & C & D\n/**\n * 合并多个对象的属性\n * 1. 该合并的方式为浅层合并，只会合并一层的对象\n * 2. 默认忽略值为 undefined/null 的属性\n * @param target 覆盖的对象上\n * @param  {...Object} sources 任意数量的对象\n * @returns 合并后的对象\n */\nexport function assign<T extends object>(\n  target: T | null | undefined,\n  ...sources: Array<any | null | undefined>\n): any {\n  return [target, ...sources].reduce((res, source) => {\n    if (isNullOrUndefined(source)) {\n      return res\n    }\n    return Object.keys(source).reduce((res, k) => {\n      const v = Reflect.get(source, k)\n      if (isNullOrUndefined(v)) {\n        return res\n      }\n      Reflect.set(res, k, v)\n      return res\n    }, res)\n  }, {})\n}\n","import { returnItself } from '../function/returnItself'\n\n/**\n * 根据不同的源对象获取不同的正则匹配，代表不需要拷贝的属性\n * @param source 源对象\n * @returns 匹配内部属性的正则表达式\n */\nfunction getInnerFieldRule(source: any): RegExp {\n  if (source instanceof Function) {\n    return /^(?:constructor|prototype|arguments|caller|name|bind|call|apply|toString|length)$/\n  } else {\n    return /^(?:toString|length)$/\n  }\n}\n\n/**\n * 拷贝对象的属性到目标对象上\n * @param target 目标对象\n * @param source 源对象\n * @returns 返回 {@param target} 目标对象\n */\nfunction _copyProps<T extends object>(target: T, source: T): T {\n  const innerField = getInnerFieldRule(source)\n  Reflect.ownKeys(source).forEach((prop) => {\n    if (typeof prop === 'string' && innerField.test(prop)) {\n      return\n    }\n    Reflect.set(target, prop, Reflect.get(source, prop))\n  })\n  return target\n}\n\n/**\n * 混合多个类\n * @param  {...Class} mixins 需要混合的多个类及其构造函数参数映射函数的 Map 集合\n * @returns 返回一个混合后的类，构造函数将的参数\n */\nexport function aggregation(mixins: Map<any, (args: any[]) => any[]>): any {\n  const arr: Array<[any, (args: any[]) => any[]]> = Array.from(mixins)\n  class Aggregate {\n    /**\n     * @param args 任意数量的参数\n     */\n    constructor(...args: any[]) {\n      arr.forEach(([Mixin, fn = returnItself]) =>\n        _copyProps(this, new Mixin(...fn(args))),\n      )\n    }\n  }\n\n  arr.forEach(([Mixin]) => {\n    _copyProps(Aggregate.prototype, Mixin.prototype)\n    _copyProps(Aggregate, Mixin)\n  })\n\n  return Aggregate\n}\n","import { wait } from './wait'\nimport { AsyncFunc } from '../interface/AsyncFunc'\n\n/**\n * 异步限制并发队列的接口\n * 主要适用于限制某个函数的并发限制\n */\ninterface IAsyncLimiting {\n  /**\n   * 限制同时存在的异步的数量\n   */\n  limit: number\n}\n\n/**\n * 包装一个异步函数为有限制并发功能的函数\n * @param fn 异步函数\n * @param options 可选参数\n * @param options.limit 并发限制数量，默认为 1\n * @returns 返回被包装后的限制并发功能的函数\n */\nexport function asyncLimiting<Fn extends AsyncFunc>(\n  fn: Fn,\n  { limit = 1 }: Partial<IAsyncLimiting> = {},\n): Fn {\n  // 当前正在执行异步的数量\n  let execCount = 0\n  // waitArr 等待的队列\n  const takeQueue: any[][] = []\n  // 是否增加了 execCount 的标记\n  let flag = false\n  return new Proxy(fn, {\n    async apply(_, _this, args) {\n      const _takeRun = async () => {\n        if (!flag) {\n          execCount++\n          flag = false\n        }\n        const tempArgs = takeQueue.shift()\n        try {\n          return await Reflect.apply(_, _this, tempArgs!)\n        } finally {\n          execCount--\n        }\n      }\n      takeQueue.push(args)\n\n      await wait(() => {\n        const result = execCount < limit\n        // 如果等待结束则必须立刻增加 execCount，避免微任务与宏任务调度可能产生错误\n        if (result) {\n          flag = true\n          execCount++\n        }\n        return result\n      })\n      return _takeRun()\n    },\n  })\n}\n","import { wait } from './wait'\n\ntype Predicate = (...args: any[]) => boolean\n\n/**\n * 默认的超时时间，可以认为是无限\n */\nconst TimeoutInfinity: Predicate = () => false\n\n/**\n * Locker 初始化对象接口\n */\ninterface ILockerInit {\n  limit?: number\n  timeout?: number\n}\n\n/**\n * 创建一个 Lock 对象，用于锁住当前的当前的异步流程\n */\nexport class Locker {\n  /**\n   * 限制并发数量，默认为 1\n   */\n  public limit: number\n  /**\n   * 超时时间，默认为无限\n   */\n  public timeout: number\n\n  /**\n   * @param options 可选项\n   * @param options.limit 限制并发数量，默认为 1\n   * @param options.timeout 超时时间，默认为无限\n   */\n  constructor({ limit = 1, timeout }: Partial<ILockerInit> = {}) {\n    this.limit = limit\n    this.timeout = timeout || (TimeoutInfinity as any)\n  }\n  /**\n   * 当前是否锁住了\n   * @returns 是否锁住了\n   */\n  public isLocked() {\n    return this.limit <= 0\n  }\n  /**\n   * 添加异步锁\n   * @param timeout 超时时间，默认为全局 timeout\n   * @returns 进行等待\n   */\n  public async lock(timeout = this.timeout) {\n    if (this.isLocked()) {\n      /**\n       * @type {Number|Function}\n       */\n      await Promise.race([\n        wait(() => {\n          const result = !this.isLocked()\n          if (result) {\n            this.limit--\n          }\n          return result\n        }),\n        wait(timeout),\n      ])\n    } else {\n      this.limit--\n    }\n  }\n  /**\n   * 删除异步锁\n   */\n  public unlock() {\n    this.limit++\n  }\n}\n","import { PromiseDeconstruct } from '../interface/PromiseDeconstruct'\n/**\n * 包装一个函数为有错误重试功能的函数\n * 注: 如果发生错误，最终将抛出最后一次调用的异常\n * @param fn 需要被包装的函数\n * @param num 调用的次数。默认为 1\n * @param errorCheck 检查返回结果是否需要重试的函数。默认只要 resolve() 就返回 true\n * @returns 包装后的有错误重试功能的函数\n */\nexport function trySometime<Fn extends (...args: any[]) => any>(\n  fn: Fn,\n  num = 1,\n  errorCheck: (res: PromiseDeconstruct<ReturnType<Fn>>) => boolean = (res) =>\n    true,\n): Fn {\n  return new Proxy(fn, {\n    async apply(target, thisArg, args) {\n      let err\n      for (let i = 0; i < num; i++) {\n        try {\n          // 等待结果出来\n          const res = await Reflect.apply(target, thisArg, args)\n          // 如果没问题就直接返回了\n          if (errorCheck(res)) {\n            return res\n          }\n          // 否则抛出异常以进行下一次重试\n          throw res\n        } catch (error) {\n          err = error\n        }\n      }\n      throw err\n    },\n  })\n}\n","import { range } from '../array/range'\nimport { ReturnFunc } from '../interface/ReturnFunc'\nimport { PromiseDeconstruct } from '../interface/PromiseDeconstruct'\n\n/**\n * 包装一个函数为有错误重试功能的函数\n * 注意: 该函数是并行运行，所以一旦调用，就会同时调用 n 次，不管之前有没有失败。。。此函数不适合包装有副作用的操作，例如修改用户信息，请使用 {@link trySometime} 替代\n * @param fn 需要被包装的函数\n * @param num 调用的次数。默认为 1\n * @param errorCheck 检查返回结果是否需要重试的函数。默认只要 resolve() 就返回 true\n * @returns 包装后的有错误重试功能的函数\n */\nexport function trySometimeParallel<Fn extends (...args: any[]) => any>(\n  fn: Fn,\n  num = 1,\n  errorCheck: (res: PromiseDeconstruct<ReturnType<Fn>>) => boolean = (res) =>\n    true,\n): Fn {\n  return new Proxy(fn, {\n    async apply(target, thisArg, args) {\n      return new Promise(async (resolve, reject) => {\n        let err\n        try {\n          await Promise.all(\n            range(0, num).map(async () => {\n              try {\n                const res = await Reflect.apply(target, thisArg, args)\n                if (errorCheck(res) === true) {\n                  resolve(res)\n                }\n                throw res\n              } catch (error) {\n                err = error\n              }\n            }),\n          )\n        } catch (error) {\n          console.log(error)\n        }\n        reject(err)\n      })\n    },\n  })\n}\n","/**\n * 深度比较两个对象是否相等\n * @param x 任何对象\n * @param y 任何对象\n * @returns 是否相等\n */\nexport function compare(x: any, y: any): boolean {\n  if (\n    (typeof x === 'number' || x instanceof Number) &&\n    (typeof y === 'number' || y instanceof Number)\n  ) {\n    const _x = +x\n    const _y = +y\n    // 如果都是 NaN 则直接返回 true\n    if (isNaN(_x) && isNaN(_y)) {\n      return true\n    }\n    // 如果是 -0/+0 则返回 false\n    if (_x === _y) {\n      return 1 / _x === 1 / _y\n    }\n    // 如果均为数字且两数之差的绝对值小于浮点数的最小精度（此举主要是为了避免浮点数的精度丢失）\n    if (Math.abs(_x - _y) < Number.EPSILON) {\n      return true\n    }\n  }\n  // 如果恒等表达式成立则直接返回 true\n  if (x === y) {\n    return true\n  }\n  // 比较正则和字符串\n  if (\n    (x instanceof RegExp && y instanceof RegExp) ||\n    ((typeof x === 'string' || x instanceof String) &&\n      (typeof y === 'string' || y instanceof String))\n  ) {\n    return x.toString() === y.toString()\n  }\n  // 如果都是时间则比较它们的时间戳\n  if (x instanceof Date && y instanceof Date) {\n    return x.getTime() === y.getTime()\n  }\n  // 如果两者有一个不是 Object 类型的话则直接返回 false\n  // 注: 此处直接返回 false 是因为特殊原生类型的都在上面处理过了\n  // 注: Array 可以按照 Object 的逻辑进行处理\n  if (!(x instanceof Object && y instanceof Object)) {\n    return false\n  }\n  // 比较它们的原型\n  if (x.prototype !== y.prototype) {\n    return false\n  }\n  // 比较构造函数\n  if (x.constructor !== y.constructor) {\n    return false\n  }\n  // 比较 y 中的属性是否全部都在 x 中\n  for (const p of Object.keys(y)) {\n    if (!Reflect.has(x, p)) {\n      return false\n    }\n  }\n  // 比较 x 中的属性是否全部都在 y 中\n  for (const p of Object.keys(x)) {\n    if (!Reflect.has(y, p)) {\n      return false\n    }\n    // 比较每个元素的类型，如果不同则直接返回 false\n    if (typeof y[p] !== typeof x[p]) {\n      return false\n    }\n    // 递归比较每个元素\n    if (!compare(x[p], y[p])) {\n      return false\n    }\n  }\n  // 全部比较完成仍然没有结果就返回 true\n  return true\n}\n","/**\n * 阻塞主线程指定时间\n * 注: 和 {@see wait} 不同，该函数会真的阻塞住主线程，即这段时间内其他的代码都无法执行，例如用户的点击事件！\n * @param time 阻塞毫秒数\n */\nexport function sleep(time: number) {\n  const end = performance.now() + time\n  while (performance.now() <= end) {}\n}\n","import { Func } from '../interface/Func'\nimport { Async } from '../interface/Async'\n\n/**\n * 包装一个函数为异步函数\n * 如果是一个异步函数，则直接返回，否则返回一部函数\n * @param fn 任意一个函数\n * @returns 返回的异步结果 Promise 对象\n * @typeparam R 原函数函数返回值类型\n */\nexport function async<Fn extends Func>(fn: Fn): Async<Fn> {\n  return new Proxy(fn, {\n    async apply(_, _this, args) {\n      return await Reflect.apply(_, _this, args)\n    },\n  }) as any\n}\n","import { wait } from './wait'\nimport { AsyncFunc } from '../interface/AsyncFunc'\n\n/**\n * 将一个异步函数包装为具有时序的异步函数\n * 注: 该函数会按照调用顺序依次返回结果，后面的调用的结果需要等待前面的，所以如果不关心过时的结果，请使用 {@link switchMap} 函数\n * @param fn 一个普通的异步函数\n * @returns 包装后的函数\n */\nexport function mergeMap<Fn extends AsyncFunc>(fn: Fn): Fn {\n  // 当前执行的异步操作 id\n  let id = 0\n  // 所执行的异步操作 id 列表\n  const ids = new Set()\n  return new Proxy(fn, {\n    async apply(_, _this, args) {\n      const prom = Reflect.apply(_, _this, args)\n      const temp = id\n      ids.add(temp)\n      id++\n      await wait(() => !ids.has(temp - 1))\n      ids.delete(temp)\n      return await prom\n    },\n  })\n}\n","import { AsyncFunc } from '../interface/AsyncFunc'\nimport { PromiseDeconstruct } from '../interface/PromiseDeconstruct'\n\n/**\n * 将一个异步函数包装为具有时序的异步函数\n * 注: 该函数会丢弃过期的异步操作结果，这样的话性能会稍稍提高（主要是响应比较快的结果会立刻生效而不必等待前面的响应结果）\n * @param fn 一个普通的异步函数\n * @returns 包装后的函数\n */\nexport function switchMap<Fn extends AsyncFunc>(fn: Fn): Fn {\n  // 当前执行的异步操作 id\n  let id = 0\n  // 最后一次异步操作的 id，小于这个的操作结果会被丢弃\n  let last = 0\n  // 缓存最后一次异步操作的结果\n  let cache: PromiseDeconstruct<ReturnType<Fn>>\n  return new Proxy(fn, {\n    async apply(_, _this, args) {\n      const temp = id\n      id++\n      const res = await Reflect.apply(_, _this, args)\n      if (temp < last) {\n        return cache\n      }\n      cache = res\n      last = temp\n      return res\n    },\n  })\n}\n","import { compatibleAsync } from '../async/compatibleAsync'\nimport { ReturnFunc } from '../interface/ReturnFunc'\n\n/**\n * 将指定函数包装为只调用一次，其他的调用返回旧值\n * 主要适用场景是只允许调用一次的地方，例如 Tab 的初始化\n * * 示意图:\n * a => b => c => d => e =>\n * a ==|====|====|====|====>\n *     |b   |c   |d   |e  (die)\n *\n * @param fn 需要包装的函数\n * @returns 包装后的函数\n */\nexport function once<R, Fn extends ReturnFunc<R>>(\n  fn: Fn,\n): Fn & { origin: Fn; clear: () => void } {\n  let flag = true\n  let cache: R\n  const res = new Proxy(fn, {\n    apply(target, thisArg, args) {\n      if (!flag) {\n        return cache\n      }\n      flag = false\n      // 如果是异步函数则返回异步的结果\n      return compatibleAsync(Reflect.apply(target, thisArg, args), (res) => {\n        cache = res\n        return cache\n      })\n    },\n  })\n  return Object.assign(res, {\n    origin: fn,\n    clear() {\n      cache = null as any\n    },\n  })\n}\n","import { wait } from './wait'\nimport { AsyncFunc } from '../interface/AsyncFunc'\n\n/**\n * 将一个异步函数包装为具有时序的异步函数\n * 注: 该函数会按照调用顺序依次返回结果，后面的执行的调用（不是调用结果）需要等待前面的，此函数适用于异步函数的内里执行也必须保证顺序时使用，否则请使用 {@link mergeMap} 函数\n * 注: 该函数其实相当于调用 {@code asyncLimiting(fn, {limit: 1})} 函数\n * 例如即时保存文档到服务器，当然要等待上一次的请求结束才能请求下一次，不然数据库保存的数据就存在谬误了\n * @param fn 一个普通的异步函数\n * @returns 包装后的函数\n */\nexport function concatMap<Fn extends AsyncFunc>(fn: Fn): Fn {\n  // 当前执行的异步操作 id\n  let id = 0\n  // 所执行的异步操作 id 列表\n  const ids = new Set()\n  return new Proxy(fn, {\n    async apply(_, _this, args) {\n      const temp = id\n      ids.add(temp)\n      id++\n      await wait(() => !ids.has(temp - 1))\n      const res = await Reflect.apply(_, _this, args)\n      ids.delete(temp)\n      return res\n    },\n  })\n}\n","import { range } from '../array/range'\nimport { ReturnFunc } from '../interface/ReturnFunc'\nimport { Func } from '../interface/Func'\n\n/**\n * 重复执行指定的函数\n * @param num 重复的次数\n * @param fn 执行的函数，如果是异步函数，则返回 Array.<Promise>\n * @param  {...Object} args 参数\n * @returns 执行返回结果\n */\nexport function repeatedCall<Fn extends Func>(\n  num: number,\n  fn: Fn,\n  ...args: Parameters<Fn>\n): ReturnType<Fn>[] {\n  return range(0, num).map(() => fn(...(args as any)))\n}\n","/**\n * 发布订阅模式\n * @typeparam T 订阅主题的类型，虽然可以为 any，但这里是刻意进行限制以避免 “全局” 的发布订阅中心对象\n * @deprecated 已废弃，请使用语义更好、类型安全且 API 更强大的 {@see EventEmitter} 进行事件总线处理\n */\nexport class PubSubMachine<T> {\n  /**\n   * 订阅者集合\n   */\n  private subMap = new Map<T, Function[]>()\n  /**\n   * 发布一个主题\n   * @param topic 发布的主题\n   * @param [args] 主题订阅所需要的参数\n   */\n  public pub(topic: any, ...args: any[]) {\n    const fns = this.subMap.get(topic)\n    if (fns === undefined) {\n      return\n    }\n    fns.forEach((fn) => fn(...args))\n  }\n  /**\n   * 订阅一个主题\n   * @param topic 订阅的主题\n   * @param fn 回调的函数\n   */\n  public sub(topic: any, fn: Function) {\n    if (!this.subMap.has(topic)) {\n      this.subMap.set(topic, [])\n    }\n    this.subMap.get(topic)!.push(fn)\n  }\n  /**\n   * 取消订阅\n   * @param topic 订阅的主题\n   * @param fn 订阅的函数，没有则删除这个主题下所有的函数\n   */\n  public unsub(topic: any, fn?: Function) {\n    if (fn === undefined) {\n      this.subMap.delete(topic)\n      return\n    }\n    if (!this.subMap.has(topic)) {\n      return\n    }\n    const fns = this.subMap.get(topic)\n    fns!.splice(fns!.indexOf(fn), 1)\n  }\n}\n","import { arrayToMap } from './arrayToMap'\n\n/**\n * 提取对象数组为 Map\n * @param arr 对象数组\n * @param fields 提取的字段\n * @returns 提取字段名对应其字段值数组的 Map\n * @typeparam T 数组元素的类型，必须为可提取字段的对象\n */\nexport function extractFieldMap<T extends object>(\n  arr: T[],\n  fields: PropertyKey[],\n) {\n  return arr.reduce(\n    (res: Map<PropertyKey, any[]>, v: T) => {\n      for (const [k, _arr] of res) {\n        _arr.push(Reflect.get(v, k))\n      }\n      return res\n    },\n    arrayToMap(\n      fields,\n      (k) => k,\n      () => new Array<any>(),\n    ),\n  )\n}\n","/**\n * 数组按照指定长度进行分段为二维数组\n * 注: num 必须要大于 1\n * @param arr 要进行分段的数组\n * @param num 每段的长度\n * @returns 分段后的二维数组\n */\nexport function segmentation<T>(arr: T[], num: number): T[][] {\n  return arr.reduce((res, v, i) => {\n    const index = (i + 1) % num\n    if (index === 1) {\n      res.push([])\n    }\n    res[res.length - 1].push(v)\n    return res\n  }, new Array<T[]>())\n}\n","/**\n * 切换 DOM 元素的 class\n * @param {Element} el DOM 元素\n * @param {Object} obj 切换的状态/class 键值对象\n * @return 根据状态切换 class 的函数\n */\nexport function toggleClass<K extends Exclude<PropertyKey, symbol>>(\n  el: Element,\n  obj: Record<K, string>,\n) {\n  const arr = Array.from(Object.values(obj)) as string[]\n  /**\n   * 返回切换 class 的函数\n   * @param state 切换的状态\n   */\n  return function toggle(state: K) {\n    arr.forEach((v) => el.classList.remove(v))\n    el.classList.add(obj[state])\n  }\n}\n","/**\n * 部分应用后返回的函数\n */\ninterface IRFunc extends Function {\n  /**\n   * 是否为偏函数，默认为 true 以标识偏函数\n   */\n  _partial: boolean\n  /**\n   * 剩余参数的长度\n   */\n  _length: number\n  /**\n   * 重写 toString 便于调试\n   */\n  toString: () => string\n}\n\n/**\n * 将函数包装为偏函数\n * 注: 该函数模仿了 underscore 的 partial 函数\n * @param fn 需要包装的函数\n * @param  {...any} args 应用的部分参数\n * @returns 包装后的函数\n */\nexport function partial(fn: Function, ...args: any[]): IRFunc {\n  const realArgs = args.filter((arg) => arg !== partial._)\n  // 如果函数参数足够则调用传入的函数\n  if (realArgs.length >= fn.length) {\n    return fn(...realArgs)\n  }\n\n  /**\n   * 最终返回的函数\n   * @param otherArgs 接受任意参数\n   * @returns 返回一个函数，或者函数调用完成返回结果\n   */\n  function innerFn(...otherArgs: any[]): Function {\n    // 记录需要移除补到前面的参数\n    const removeIndexSet = new Set()\n    let i = 0\n    const newArgs = args.map((arg) => {\n      if (\n        arg !== partial._ ||\n        otherArgs[i] === undefined ||\n        otherArgs[i] === partial._\n      ) {\n        return arg\n      }\n      removeIndexSet.add(i)\n      // 每次补偿前面的 partial._ 参数计数器 +1\n      return otherArgs[i++]\n    })\n    const newOtherArgs = otherArgs.filter((_v, i) => !removeIndexSet.has(i))\n    return partial(fn, ...newArgs, ...newOtherArgs)\n  }\n  // 定义偏函数的剩余参数长度，便于在其他地方进行部分参数应用\n  // 注: 不使用 length 属性的原因是 length 属性\n  innerFn._length = fn.length - args.filter((arg) => arg !== partial._).length\n  // 自定义 toString 函数便于调试\n  innerFn.toString = () =>\n    `name: ${fn.name}, args: [${args.map((o) => o.toString()).join(', ')}]`\n  innerFn._partial = true\n  return innerFn\n}\n\n/**\n * 偏的占位符，需要应用后面的参数时使用\n * 例如 {@link partial(fn)(partial._, 1)} 意味着函数 fn 的第二个参数将被确定为 1\n */\npartial._ = Symbol('_')\n","import { groupBy } from '../array/groupBy'\n\n/**\n * 缓存的事件监听对象\n */\ninterface CacheListener {\n  /**\n   * @property 事件的类型\n   */\n  type: string\n  /**\n   * @property 事件的监听函数\n   */\n  listener: Function\n  /**\n   * @property 事件监听器选项\n   */\n  options?: boolean | AddEventListenerOptions\n}\n\ntype EventOriginType = Document | Element | Window\n\n/**\n * 事件工具类\n */\nexport class EventUtil {\n  /**\n   * 缓存的事件监听对象映射表\n   */\n  private static listenerMap: Map<EventOriginType, CacheListener[]> = new Map()\n\n  //region add\n\n  static add<K extends keyof DocumentEventMap>(\n    dom: Document,\n    type: K,\n    listener: (this: Document, ev: DocumentEventMap[K]) => any,\n    options?: boolean | AddEventListenerOptions,\n  ): void\n  static add(\n    dom: Document,\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | AddEventListenerOptions,\n  ): void\n  static add<K extends keyof ElementEventMap>(\n    el: Element,\n    type: K,\n    listener: (this: Element, ev: ElementEventMap[K]) => any,\n    options?: boolean | AddEventListenerOptions,\n  ): void\n  static add(\n    el: Element,\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | AddEventListenerOptions,\n  ): void\n  static add<K extends keyof WindowEventMap>(\n    window: Window,\n    type: K,\n    listener: (this: Window, ev: WindowEventMap[K]) => any,\n    options?: boolean | AddEventListenerOptions,\n  ): void\n  static add(\n    window: Window,\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | AddEventListenerOptions,\n  ): void\n  static add(\n    dom: EventOriginType,\n    type: any,\n    listener: any,\n    options?: boolean,\n  ): void {\n    if (!EventUtil.listenerMap.has(dom)) {\n      EventUtil.listenerMap.set(dom, [])\n    }\n    EventUtil.listenerMap.get(dom)!.push({\n      type,\n      listener,\n      options,\n    })\n    dom.addEventListener(type, listener, options)\n  }\n\n  //endregion\n\n  //region remove\n\n  static remove<K extends keyof DocumentEventMap>(\n    dom: Document,\n    type: K,\n    listener: (this: Document, ev: DocumentEventMap[K]) => any,\n    options?: boolean | EventListenerOptions,\n  ): void\n  static remove(\n    dom: Document,\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | EventListenerOptions,\n  ): void\n  static remove<K extends keyof ElementEventMap>(\n    el: Element,\n    type: K,\n    listener: (this: Element, ev: ElementEventMap[K]) => any,\n    options?: boolean | EventListenerOptions,\n  ): void\n  static remove(\n    el: Element,\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | EventListenerOptions,\n  ): void\n  static remove<K extends keyof WindowEventMap>(\n    dom: Window,\n    type: K,\n    listener: (this: Window, ev: WindowEventMap[K]) => any,\n    options?: boolean | EventListenerOptions,\n  ): void\n  static remove(\n    dom: Window,\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | EventListenerOptions,\n  ): void\n  static remove(\n    dom: EventOriginType,\n    type: any,\n    listener: any,\n    options?: boolean,\n  ): void {\n    dom.removeEventListener(type, listener as any, options)\n    EventUtil.listenerMap.set(\n      dom,\n      (EventUtil.listenerMap.get(dom) || []).filter(\n        (cacheListener) =>\n          cacheListener.type !== type ||\n          cacheListener.listener !== listener ||\n          cacheListener.options !== options,\n      ),\n    )\n  }\n\n  //endregion\n\n  //region removeByType\n\n  static removeByType<K extends keyof DocumentEventMap>(\n    dom: Document,\n    type: K,\n    options?: boolean | EventListenerOptions,\n  ): CacheListener[]\n  static removeByType(\n    dom: Document,\n    type: string,\n    options?: boolean | EventListenerOptions,\n  ): CacheListener[]\n  static removeByType<K extends keyof ElementEventMap>(\n    el: Element,\n    type: K,\n    options?: boolean | EventListenerOptions,\n  ): CacheListener[]\n  static removeByType(\n    el: Element,\n    type: string,\n    options?: boolean | EventListenerOptions,\n  ): CacheListener[]\n  static removeByType<K extends keyof WindowEventMap>(\n    dom: Window,\n    type: K,\n    options?: boolean | EventListenerOptions,\n  ): CacheListener[]\n  static removeByType(\n    dom: Window,\n    type: string,\n    options?: boolean | EventListenerOptions,\n  ): CacheListener[]\n  static removeByType(\n    dom: EventOriginType,\n    type: any,\n    options?: boolean,\n  ): CacheListener[] {\n    const listenerList = EventUtil.listenerMap.get(dom)\n    if (listenerList === undefined) {\n      return []\n    }\n    const map = groupBy(\n      listenerList,\n      (cacheListener) =>\n        type === cacheListener.type && options === cacheListener.options,\n    )\n    const removeCacheListenerList = map.get(true) || []\n    const retainCacheListenerList = map.get(true) || []\n    EventUtil.listenerMap.set(dom, retainCacheListenerList)\n    return removeCacheListenerList.map((cacheListener) => {\n      dom.removeEventListener(\n        cacheListener.type,\n        cacheListener.listener as any,\n        cacheListener.options,\n      )\n      return cacheListener\n    })\n  }\n\n  //endregion\n}\n","/**\n * 加载一个远程样式文件\n * @param href 远程 CSS 样式路径\n * @returns 等待异步加载样式完成\n */\nexport function loadStyle(href: string): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const link = document.createElement('link')\n    link.rel = 'stylesheet'\n    link.href = href\n    link.addEventListener('load', () => resolve())\n    link.addEventListener('error', reject)\n    document.body.appendChild(link)\n  })\n}\n","/**\n * 补 0 函数\n * @param time 为时分秒补首位 0\n * @returns 补零得到的字符串\n */\nfunction zeroPadding(time: number): string {\n  return (time >= 10 ? '' : '0') + time\n}\n\n/**\n * 秒表\n * 标准格式 `HH:mm:ss`\n * 主要适用场景是格式化/解析时间差值\n */\nexport class Stopwatch {\n  /**\n   * 格式化一个以秒为单位的绝对时间为标准时间格式的字符串\n   * @param time 时间/s\n   * @returns 格式化后的字符串\n   */\n  static format(time: number): string {\n    const seconds = time % 60\n    const minutes = Math.floor(time / 60) % 60\n    const hours = Math.floor(time / 60 / 60)\n    return `${zeroPadding(hours)}:${zeroPadding(minutes)}:${zeroPadding(\n      seconds,\n    )}`\n  }\n\n  /**\n   * 解析一个标准的时间字符串为秒为单位的绝对时间\n   * @param str 时间字符串\n   * @returns 解析得到的时间/s\n   */\n  static parse(str: string): number {\n    const [, hours, minutes, seconds] = /(\\d+):(\\d+):(\\d+)/.exec(\n      str,\n    ) as string[]\n    return (\n      parseInt(hours) * 60 * 60 + parseInt(minutes) * 60 + parseInt(seconds)\n    )\n  }\n}\n","import { ReturnFunc } from '../interface/ReturnFunc'\n\n/**\n * 提醒用户当前页面有正在执行的操作，暂时不能离开\n * 注：用户实际上可以不管该提醒\n * @param fn 谓词，是否要提醒不要关闭\n * @returns 返回删除这个事件监听的函数\n */\nexport function remindLeavePage(fn: ReturnFunc<boolean> = () => false) {\n  const listener = (e: BeforeUnloadEvent) => {\n    if (fn()) {\n      return false\n    }\n    const confirmationMessage = '请不要关闭页面'\n    e.returnValue = confirmationMessage //Gecko + IE\n    return confirmationMessage //Webkit, Safari, Chrome etc.\n  }\n\n  window.addEventListener('beforeunload', listener)\n  return () => window.removeEventListener('beforeunload', listener)\n}\n","type EventType = string | number\n\ntype CallbackFunc<Args extends any[]> = Args extends [infer P1]\n  ? (p1: P1) => void\n  : Args extends [infer P1, infer P2]\n  ? (p1: P1, p2: P2) => void\n  : (...args: Args) => void\n\n/**\n * 事件总线\n * 实际上就是发布订阅模式的一种简单实现\n * 类型定义受到 {@link https://github.com/andywer/typed-emitter/blob/master/index.d.ts} 的启发，不过只需要声明参数就好了，而不需要返回值（应该是 {@code void}）\n */\nexport class EventEmitter<Events extends Record<EventType, any[]>> {\n  private readonly events = new Map<keyof Events, Function[]>()\n\n  /**\n   * 添加一个事件监听程序\n   * @param type 监听类型\n   * @param callback 处理回调\n   * @returns {@code this}\n   */\n  add<E extends keyof Events>(type: E, callback: CallbackFunc<Events[E]>) {\n    const callbacks = this.events.get(type) || []\n    callbacks.push(callback)\n    this.events.set(type, callbacks)\n    return this\n  }\n  /**\n   * 移除一个事件监听程序\n   * @param type 监听类型\n   * @param callback 处理回调\n   * @returns {@code this}\n   */\n  remove<E extends keyof Events>(type: E, callback: CallbackFunc<Events[E]>) {\n    const callbacks = this.events.get(type) || []\n    this.events.set(\n      type,\n      callbacks.filter((fn: any) => fn !== callback),\n    )\n    return this\n  }\n  /**\n   * 移除一类事件监听程序\n   * @param type 监听类型\n   * @returns {@code this}\n   */\n  removeByType<E extends keyof Events>(type: E) {\n    this.events.delete(type)\n    return this\n  }\n  /**\n   * 触发一类事件监听程序\n   * @param type 监听类型\n   * @param args 处理回调需要的参数\n   * @returns {@code this}\n   */\n  emit<E extends keyof Events>(type: E, ...args: Events[E]) {\n    const callbacks = this.events.get(type) || []\n    callbacks.forEach((fn) => {\n      fn(...args)\n    })\n    return this\n  }\n\n  /**\n   * 获取一类事件监听程序\n   * @param type 监听类型\n   * @returns 一个只读的数组，如果找不到，则返回空数组 {@code []}\n   */\n  listeners<E extends keyof Events>(type: E) {\n    return Object.freeze(this.events.get(type) || [])\n  }\n}\n","import { compatibleAsync } from './compatibleAsync'\n\ntype NoParamVoidFunc = () => void | PromiseLike<void>\n\n/**\n * 一个简单的微任务队列辅助类，使用（宏）命令模式实现\n * 注：该 class 是为了解决问题 https://segmentfault.com/q/1010000019115775\n */\nexport class MicrotaskQueue {\n  // task 列表\n  public tasks: NoParamVoidFunc[] = []\n  // 当前是否存在正在执行的 task\n  private lock = false\n  add(func: NoParamVoidFunc) {\n    this.tasks.push(func)\n    this.execute()\n    return this\n  }\n  execute() {\n    if (this.lock) {\n      return\n    }\n    this.lock = true\n    const goNext = () => {\n      if (this.tasks.length) {\n        const task = this.tasks.shift()!\n        compatibleAsync(task(), () => goNext())\n      } else {\n        this.lock = false\n      }\n    }\n    Promise.resolve().then(goNext)\n  }\n}\n","/**\n * 取值的字符串\n */\nconst rangeStr =\n  '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\nconst rangeLen = rangeStr.length\n\n/**\n * 生成一个随机字符串\n * @param len\n */\nexport function randomStr(len: number) {\n  let res = ''\n  for (let i = 0; i < len; i++) {\n    res += rangeStr.charAt(Math.floor(Math.random() * rangeLen))\n  }\n  return res\n}\n","/**\n * 解析字段字符串为数组\n * @param str 字段字符串\n * @returns 字符串数组，数组的 `[]` 取法会被解析为数组的一个元素\n */\nexport function parseFieldStr(str: string): string[] {\n  return str\n    .split(/[\\.\\[]/)\n    .map((k) => (/\\]$/.test(k) ? k.slice(0, k.length - 1) : k))\n}\n","import { TypeValidator } from '../obj/TypeValidator'\nimport { isNullOrUndefined } from '../obj/isNullOrUndefined'\nimport { parseFieldStr } from '../idea/parseFieldStr'\n\n/**\n * 安全的深度获取对象的字段\n * TODO 该函数尚处于早期测试阶段\n * 注: 只要获取字段的值为 {@type null|undefined}，就会直接返回 {@param defVal}\n * 类似于 ES2019 的可选调用链特性: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/%E5%8F%AF%E9%80%89%E9%93%BE\n * @param obj 获取的对象\n * @param fields 字段字符串或数组\n * @param [defVal] 取不到值时的默认值，默认为 null\n */\nexport function get(\n  obj: object,\n  fields: PropertyKey[] | string,\n  defVal: any = null,\n): any {\n  if (TypeValidator.isString(fields)) {\n    fields = parseFieldStr(fields)\n  }\n  let res = obj\n  for (const field of fields) {\n    try {\n      res = Reflect.get(res, field)\n      if (isNullOrUndefined(res)) {\n        return defVal\n      }\n    } catch (e) {\n      return defVal\n    }\n  }\n  return res\n}\n","import { TypeValidator } from '../obj/TypeValidator'\nimport { parseFieldStr } from '../idea/parseFieldStr'\n\n/**\n * 安全的深度设置对象的字段\n * TODO 该函数尚处于早期测试阶段\n * 注: 只要设置字段的值为 {@type null|undefined}，就会直接返回 {@param defVal}\n * 类似于 ES2019 的可选调用链特性: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/%E5%8F%AF%E9%80%89%E9%93%BE\n * @param obj 设置的对象\n * @param fields 字段字符串或数组\n * @param [val] 设置字段的值\n */\nexport function set(\n  obj: object,\n  fields: PropertyKey[] | string,\n  val: any,\n): boolean {\n  if (TypeValidator.isString(fields)) {\n    fields = parseFieldStr(fields)\n  }\n  let res: any = obj\n  for (let i = 0, len = fields.length; i < len; i++) {\n    const field = fields[i]\n    if (i === len - 1) {\n      res[field] = val\n      return true\n    }\n    res = res[field]\n    if (!TypeValidator.isObject(res)) {\n      return false\n    }\n  }\n  return false\n}\n","/**\n * 获取当前选中的文本\n * @returns 当前选中的文本\n */\nexport function getSelectText() {\n  return getSelection()!.toString()\n}\n","/**\n * 矩形大小\n */\ninterface RectSize {\n  width: number\n  height: number\n}\n\n/**\n * 获取图片的尺寸\n * @param url\n */\nexport function imageSize(url: string) {\n  return new Promise<RectSize>((resolve, reject) => {\n    const image = new Image()\n    image.addEventListener('load', function () {\n      resolve({\n        width: this.width,\n        height: this.height,\n      })\n    })\n    image.addEventListener('error', (ev) => {\n      reject(ev.error)\n    })\n    image.src = url\n  })\n}\n","/**\n * 获取鼠标的位置\n * @param e 触发的鼠标事件对象\n * @returns 鼠标的坐标\n */\nexport function getMousePos(e: MouseEvent) {\n  const scrollX =\n    document.documentElement.scrollLeft || document.body.scrollLeft\n  const scrollY = document.documentElement.scrollTop || document.body.scrollTop\n  const x = e.pageX || e.clientX + scrollX\n  const y = e.pageY || e.clientY + scrollY\n  return { x, y }\n}\n","import { wait } from '../async/wait'\n\n/**\n * 将多个并发异步调用合并为一次批处理\n * @param handle 批处理的函数\n * @param ms 等待的时长（时间越长则可能合并的调用越多，否则将使用微任务只合并一次同步执行的所有调用）\n */\nexport function batch<P extends any[], R extends any>(\n  handle: (list: P[]) => Promise<Map<P, R | Error>>,\n  ms: number = 0,\n): (...args: P) => Promise<R> {\n  //参数 => 结果 映射\n  const resultCache = new Map<string, R | Error>()\n  //参数 => 次数的映射\n  const paramCache = new Map<string, number>()\n  //当前是否被锁定\n  let lock = false\n  return async function (...args: P) {\n    const key = JSON.stringify(args)\n    paramCache.set(key, (paramCache.get(key) || 0) + 1)\n    await Promise.all([wait(() => resultCache.has(key) || !lock), wait(ms)])\n    if (!resultCache.has(key)) {\n      try {\n        lock = true\n        Array.from(\n          await handle(Array.from(paramCache.keys()).map((v) => JSON.parse(v))),\n        ).forEach(([k, v]) => {\n          resultCache.set(JSON.stringify(k), v)\n        })\n      } finally {\n        lock = false\n      }\n    }\n    const value = resultCache.get(key)!\n    paramCache.set(key, paramCache.get(key)! - 1)\n    if ((paramCache.get(key) || 0) <= 0) {\n      paramCache.delete(key)\n      resultCache.delete(key)\n    }\n    if (value instanceof Error) {\n      resultCache.delete(key)\n      throw value\n    }\n    return value as R\n  }\n}\n","export type ObjectEntries<T extends object> = [keyof T, T[keyof T]][]\n\n/**\n * 从一个对象中挑选出来几个指定的字段\n * @param obj 指定对象\n * @param fieldList 指定对象字段列表\n * @returns 返回挑选字段组成的新对象\n */\nexport function pick<T extends object, K extends keyof T>(\n  obj: T,\n  ...fieldList: K[]\n): Pick<T, K> {\n  const set = new Set(fieldList)\n  return (Object.entries(obj) as ObjectEntries<T>).reduce((res, [k, v]) => {\n    if (set.has(k as K)) {\n      Reflect.set(res, k, v)\n    }\n    return res\n  }, {} as Pick<T, K>)\n}\n","import { safeExec } from '../function/safeExec'\n\nclass WebStorage implements Storage {\n  constructor(private storage: Storage) {}\n\n  get length() {\n    return this.storage.length\n  }\n\n  clear = (): void => {\n    this.storage.clear()\n  }\n\n  getItem = (key: string): string | null => this.storage.getItem(key)\n\n  key = (index: number): string | null => this.storage.key(index)\n\n  removeItem = (key: string): void => {\n    this.storage.removeItem(key)\n  }\n\n  setItem = (key: string, value: string): void => {\n    this.storage.setItem(key, value)\n  }\n}\n\ntype Null<T> = {\n  [P in keyof T]: T[P] | null\n}\n\n/**\n * 代理 Storage 使之更简单易用\n * @param storage\n */\nexport function proxyStorage<T extends object>(\n  storage: Storage,\n): Storage & Null<T> {\n  const kSet = new Set([\n    'storage',\n    'length',\n    'clear',\n    'getItem',\n    'setItem',\n    'removeItem',\n    'key',\n  ] as (keyof Storage)[])\n  return new Proxy(new WebStorage(storage), {\n    get(target: Storage, p: string, receiver: any): any {\n      if (kSet.has(p)) {\n        return Reflect.get(target, p, receiver)\n      }\n      return safeExec(() => JSON.parse(target.getItem(p.toString())!), null)\n    },\n    set(target: Storage, p: string, value: any, receiver: any): boolean {\n      if (kSet.has(p as any)) {\n        return Reflect.set(target, p, receiver)\n      }\n      target.setItem(\n        p.toString(),\n        value !== undefined && value !== null ? JSON.stringify(value) : value,\n      )\n      return true\n    },\n  }) as any\n}\n","/**\n * 将对象的键和值进行映射\n * @param obj\n * @param func\n */\nexport function mapObject<R extends Record<string, any>>(\n  obj: Record<string, any>,\n  func: (kv: [string, any]) => [string, any],\n): R {\n  return Object.entries(obj).reduce((res, kv) => {\n    const [k, v] = func(kv as any)\n    res[k] = v\n    return res\n  }, {} as any)\n}\n"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;;AAEA;AACA;;ACVA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;;AAEA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjFA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/kBA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;;AAEA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;ACZA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;;AAEA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;ACRA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;ACRA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AClIA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;ACVA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;ACvBA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;ACnCA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnHA;AACA;AACA;AACA;;;ACGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;ACVA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;ACVA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvBA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3GA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClHA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtDA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9EA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9MA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxCA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;;AAEA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;"}